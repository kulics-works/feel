# example

# {
    System
    System.IO
    System.Collections.Generic
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    System.Threading.Tasks

    . = example.example_static
}

/*
   // main function
*/
Main = () {
    Print("main function")
    // run test
    Test_type()
    Test_operator()
    Test_string()
    Test_optional()
    Test_list()
    Test_dict()
    Test_switch()
    Test_if()
    Test_foreach()
    Test_while()
    X = Test_func("testcall")
    Test_func_params(1, 2,
    (a : Int, b : Int, c : Int, d : Int -> z : Str, a : Int, b : Int, c : Int) {
        <- "", a, b, c
    })
    Test_check()
    Test_type_convert()
    Test_lambda()
    Test_async()

    Y = Test_tuple(1).To_Str()

    P = example.App$()

    P.C(1)
    Test_interface(P)

    P.Test_func_template[Int, Str](1, "2").Test_package()
    
    @ true {
        ~@
    }
    
    ? 1 == 1 {
        Print("test exception expression")
    }

    Read()
}

`get, set`
static_x = 0

`get, set`
static_y = "hello"

static_g : Int = 3

Test_tuple = (i : Int -> v : Str) {
    <- "tuple"
}

Test_type = () {
    I1 : I8 = 1              // sbyte
    I2 : I16 = 1             // short
    I3 : I32 = 1             // Int
    I4 : I64 = 1             // long
    U1 : U8 = 1              // byte
    U2 : U16 = 1             // ushort
    U3 : U32 = 1             // uint
    U4 : U64 = 1             // ulong
    F1 : F32 = 1             // float
    F2 : F64 = 1             // double
    Char1 : Chr = 'a'        // char
    String1 : Str = "123"    // string
    Bool1 : Bool = false     // bool
    Int1 : Int = 1           // Int
    Num1 : Num = 1.0         // double
    Byte1 : Byte = 1         // byte
    Any1 : Any = 1           // object
}

Test_operator = () {
    i : Str = "128.687"
    i += ".890"
    A = 003.141592653e3
    b : Int
    b = 2020_01_16
    b = 0b1010_1101
    b = 0X56_fa_C4
    b += Const_data
    b = + - b
    b = b + 1
    b = b * 2
    b = b / 2
    b = b % 2
    b = (b ^ 2) :> Int
    Print(" mark string Int \b \{b}123{} \\{b} \{i;i}")
    Print(""" "raw" mark string \b
     Int \{b}123{} \ {}
      \{i}
    """)
    Print(""" 
       " raw "
        string
      """, """""")
    c = false
    c = 1 <> 2
    c = 3 == 3
    c = 3 >= 1
    c = 1 <= 3
    c = ~~c
    c = true || false
    c = true && false
    d = (2018.0309).To_Int()
    d = ~~~ d &&& 1 ||| 2 ^^^ 3 <<< 1 >>> 2
    Print(b.To_Str(), d)
}

Test_string = () {
    @ "love programming" => E {
        ? E == 'e' {
            Print("love programming")
        }
    }
}

Test_optional = () {
    a : ?Int
    a = 1
    a?.To_Str()
    B : ?Str = ""
    B?.To_Str()
    C : ?Any = nil
    D : ?App = nil
    E : ?List[?Int] = List_of[?Int](0)
    E?.(0)?.To_Str()?.To_Str()
    F = D ?| App$()
}

Test_reference = () {
    x : Int = 1
    y : ?Int = 2
    Swap = (a : !Int, b : !?Int) {
        b, a = a, b ?| 2
    }
    Swap(x!, y!)
}

Test_list = () {
    Single = List_of(1)
    numbers = List_of(1, 2, 5, 6, 8, 4)
    numbers.Append(3 + 7)
    numbers.Remove(6)
    Three = 3
    numbers.(Three) = 5
    take = numbers.(0)
    take = In_package_array$().Arr.(2)
    Anys = List_of[Any]("123", 432, App$())
    Numbers_in_numbers = List_of(List_of(1, 1, 1), List_of(1, 1, 1))
    Numbers_in_numbers.(0).(0) = 3
    Empty = List[List[Int]]$()
    Array : Array[Int] = Array_of(1, 2, 3)
    @ numbers.WithIndex() => i, v {
        Print(i, " :", v)
    }
    Slice = numbers.(0..)
    Slice2 = numbers.(..3)
}

Test_dict = () {
    Empty = Dict[Str, Dict[Int, Int]]$()
    temp = Dict_of(Pair_of("k1", 1), Pair_of("k2", 2))
    temp.("k3") = 3
    @ temp.WithIndex() => k, v {
        Print(k)
        Print(v)
    }
    temp.Remove("k1")
    Print(temp.("k2"))
}

Test_combined_type = () {
    // swift [Int:[[Str:[Str:[Str]]]]]
    // go map[Int][]map[Str]map[Str][]Str
    // c# Dictionary<Int,List<Dictionary<Str,Dictionary<Str,List<Str>>>>>
    Feel : ?Dict[Int, List[Dict[Str, Dict[Str, List[Str]]]]] = nil
}

Test_if = () {
    X = 5
    ? X == 2 { 
        Print(2)
    } | X == 3 {
        Print(3)
    } | { 
        Print("else")
    }
    ? X == 5 {
        Print("yes")
    }
}

Test_type_convert = () {
    A : Any = Dict[Str, Int]$()
    B = A :> Dict[Str, Int]
    X = App$()
    Y = X :> Program
    Z1 = (12.34).To_F32()
    Z2 = Z1.To_I64()
    Print( Z2.To[Any]().To[I64]() )
    Print( Y :: Program )
    Print( (X :> Program).running )
    Print( typeof(Program) )
}

Test_switch = () {
    X : Any = 3
    ? X == 1, 2, 3 {
        Print("1,2,3") 
    } | == nil {
        Print("null")
    } | :: Str {
        Print("string")
    } | :: Int => i {
        Print("Int")
    } | {
        Print("default")
    }
}

Test_foreach = () {
    Print("\n 0 to 10 step 2: ")
    @ 0 ... 10 ~ 2 => E {
        Print(E, ", ", "")
    }
    Print("\n 0 to 7: ")
    @ 0 .. 8 => E {
        Print(E, ", ", "")
    }
    Print("\n 8 to 1: ")
    @ 8 .. 0 ~ -1 => E {
        Print(E, ", ", "")
    }
    Print("\n 10 to 2 step 2: ")
    @ 10 ... 0 ~ -2 => E {
        Print(E, ", ", "")
        ? E == 6 {
            @
        }
    }
    Print("\n 0 to 7 reversed: ")
    @ (0 .. 8).Reversed() => E {
        Print(E, ", ", "")
    }
    @ (0 .. 8).Reversed().Reversed() => E {
        Print(E, ", ", "")
    }
    Print(" ")
    Arr = List[Int]$()
    @ Arr => I {
        Print(I)
    }
    @ 7 .. 7 => I {
        Print(I)
        ~@
    }
}

Test_while = () {
    a = 0
    B = 8
    @ a < B {
        a += 1
    } & {
        Print("loop no break")
    }
}

Test_check = () {
    z1 : ?Defer = nil
    ! Z2 = Defer$() & Z2 {
        ! {
            z1 = Defer$()
            ! Z3 = Defer$() & Z3 {
                X = 1 * 1
                Y = 1 + 1
            }
        } & ex : IOException {
            ! <- ex
        } & e {
            ! <- e
        } & {
            ? z1 <> nil {
                z1.Dispose()
            }
        }
    }
}

Test_func = (s : Str -> out1 : Str, out2 : Int) {
    s = s + "test"
    I1 = 1+1*3*9/8
    I2 = I1 + 5 + (I1 + 8)
    Infunc = () {
        <-
    }
    Infunc()

    <- s, I2
}

Test_func_params = (a : Int, b : Int, fn : (Int, Int, Int, Int ->
    Str, Int, Int, Int), arr : ...Int -> a : Int, b : Str, c : Str) {
    <- 0, "", ""
}

Test_lambda = () {
    Test1 = (fn : (Int, Int->Int, Int)) {
        i1, i2 = fn(1, 2)
    }
    Test1((i1, i2){i1, i2})

    Test2 = (fn : (->Int)) {
        i1 = fn()
    }
    Test2((){1})

    Test3 = (fn : (Int->>)) {
        fn(1)
    }
    Test3( (it : Int->>) {
        Delay~>(1000)
        Print(it)
    })
    Test3( (it->>) {
        Delay~>(1000)
        Print(it)
    })
    Test4 = (fn : (Int->>Int)) { 
        fn(18) 
    }
    Test4((it->>){it+1})
}

Test_async = (->> x : Int, y : Int, z : Str) {
    Sleep(1000)
    @ 1 .. 10 => i {
        go((->>) {
            Delay~>(1000)
            Print("task", i)
        })
    }
    Async_void = () {
        Delay~>(1000)
    }
    Func_await = (->> x : Int, y : Int, z : Str) {
        Delay(1000)
        <<- 1, 2, "123"
    }
    <- Func_await~>()
}

Test_define = () {
    a = 1
    ? a == 1 {
        b = 2
        b = 3
        a = 3
    } | a == 2 {
        b = 2
        b = 3
        ? b == 2 {
            a = 1
        }
    } | {
        b = 2
        b = 3
        a = 3
    }
    ? a == 1 {
        b = 2
        b = 3
        a = 3
        ? a == 3 {
            b = 1
            a = 1
        } | {
            a = 2
        }
    } | :: Int => c {
        c = 2
        a = 1
    } | {
        b = 2
        b = 3
        a = 3
    }
    ! {
        a = 2
    }
    & e {
        e = Exception$()
    }
}

Test_interface = (in : Protocol) {}

Const_data = 256
Const_data2 : Str = "512"
Const_data3 : Int = Const_data
Const_function = (->v : Int) { 
    <- Const_data
}

测试中文 = (甲 : Int->乙 : Int) {
    乙 = 甲 + 1
    <- 乙
}

In_package_array = $(Arr : List[Int]) {}
In_package_array = (->$me) {
    me.Arr = List_of(1,2,3,4,5)
}

Defer = $(data : Str) {
    IDisposable
    Dispose = () {}
}

App = $(
    i : Int,
    arr : Array[Int],
    _Name : Str,
    _b : Int,
    `get, set`
    a : Int,
    `get, set`
    f : Str
) {
    Program
    Protocol

    Test_package = () {
        Item = Program$()
        Item = $()
        Item2 = List[Int]$()
        Item3 = Dict[Str, Int]$()
        Item4 = Package_child$(1,2)
    }

    Test_func_template = [t1, t2](data1 : t1, data2 : t2 -> data : App) {
        <- this
    }

    C = (x : Int -> y : Int) {
        <- x + this._b
    }

    D = (->> x : Int) {
        Delay~>(1000)
        <- 3
    }

    E = (->>) {
        Delay~>(1000)
    }
}

Result = $(Data : Str) {}
Result = (data : Str->$) {
    Data = data
}

Test_package_template = [t:class]$(data : t) {
    Generic = (a : t) {}
}

Test_protocol_template = [t:class]$ {
    Test : [h:class](in : h->)
    Test : (in : t->)
}

Test_implement_template = $() {
    Test_protocol_template[Test_implement_template]
    
    Test = [h:class](in : h) {}
    Test = (in : Test_implement_template) {}
}

Program = $(`get, set`name : Str, running : Bool) {}

Protocol = $ {
    C : (x : Int -> y : Int)
    D : (->>y : Int)
    E : (->>)
}

`"SQL ORM", Table("test")`
Test_annotation = $(
    `Key, Column("id")`
    id : Str,
    `Column("nick_name")`
    nick_name : Str,
    `Column("profile")`
    profile : Str
) {}

Test_enum = $[Ok, Err] {}

Package = $(x : Int, y : Int) -> (me) {
    ParentFunc = () {
        me.x = 21
        Print("package")
    }
}
Package = (y : Int->$me) {
    me.x = Const_data
    me.y = y
}

Package_child = (x : Int, y : Int->$)(y) {
    this.x = x
}
Package_child = $() -> (me, super) {
    Package

    .ParentFunc = () {
        x = 64
        Print("package child")
    }
}