// Grammar Overview

// Export Name Space
out demo

// Import Name Space
in {
    System
    System.Text
    System.Threading.Tasks
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    . = IO.File // 可以隐藏元素使用内容
}

fun Main() do {
    // Define, 一般情况下编译器会自动判断类型
    var string Str = "10"
    var number Num = 1.2
    var integer Int = 123
    var boolean Bool = true
    var smallFloat = (1.2).To_F32() // basic obj convert

    // Const
    var PI = 3.141592653

    // Mark String
    var format = "the value is \{integer}, \{number}, \{boolean}"

    // Array
    var array Array[Int] = Array_of(1, 2, 3)

    // List
    var list List[Int] = List_of(1, 2, 3, 4, 5)
    Print( list.[0] ) // 使用下标获取

    // Dictionary, 前面为key，后面为value
    var dict Dict[Str, Bool] = Dict_of(new("1", false), new("2", true))
    Print( dict.["1"] ) // 使用key获取

    // Anonymous Template
    var v1 = dat(title Str, number Int)("nnn", 8)
    var v2 = dat(title, number)("nnn", 8) // obj infer

    // Function
    var fn fun(Int)(Int) = fun(a Int) do {
        ret a
    }

    // Function with no params no return
    fun do_something_void() do {
        do_something_a()
        do_something_b()
    }

    // Full Function with in params and out params
    fun do_something_with_params(x Int, y Str) (x Int, y Str) do {
        ret (x, y)
    }

    // Function can omit return obj
    var f = fun(x Int, y Int) do x + y
    fun f(x Int, y Int) do x + y

    // Currying
    var add = fun(x Int) do fun(y Int) do x + y

    do_something_void()
    // 使用 _ 舍弃返回值
    _ = do_something_with_params(3, "test")

    // Judge，当表达式的结果只有Bool时，相当于if，只当True时才执行
    if a do b else do c
    if a do {
        b
    } else do {
        c
    }

    if a do b else if c do d else do e
    if a do {
        b
    } else if c do {
        d
    } else do {
        e
    }

    if var a, b = 1, 2; a < b do {
        d
    } else if var c = 3; a == c do {
        d
    }

    // Judge obj
    if ib is Image_Button it do {
        it.show()
    }

    // Complex Judge
    if x in {
        case >= 0 and <= 6 or == 7, 8, 9 do
            do_something_a()
        case == 14 do
            do_something_b()
        case < 18 do
            do_something_c()
        case > 18 and < 32 do
            do_something_d()
        case is Int it do
            do_something_e()
        case is Option.Some(var v) do
            Print(v)
        else do
            do_something()
    }

    // Loop, use identify to take out single item
    for a in b do c
    for item in array do {
        Print(item)
    }
    // take index and value, both worked at Dictionary
    for index, value in array.WithIndex() do {
        Print(index, value)
    }

    // Range
    for it in 0 to 100 do {
        Print(it)
    }
    for it in 0 until 100 do {
        Print(it)
    }
    for it in 10 downto 1 by 2 do {
        Print(it)
    }
    
    // Conditional
    var a = 0
    for a < 10 do {
        a += 1
    }
    for a do b
    for var i = 0; i < 10 do {
        i += 1
    }
    // Infinite
    for do {
        if a > b do {
            break // jump out loop
        }
        continue // continue
    }
    
    // Check, listen the Exception Function
    var fi = open_file("./test.feel")
    try var f = read_file("demo.feel"); f {
        do_some_thing()
    }
    try {
        do_some_thing()
    } catch ex Exception {
        throw ex // Use ! <- to throw an Exception
    } finally {
        fi.dispose()
    }

    // Template
    dat View(width Int, height Int, background Str)

    // 可以通过 this 来访问包自身属性或方法，当作为指针类型使用时 this 是指针，否则是值类型。 this 可以自定义。
    dat Button(width Int, height Int, background Str, title Str) {
        Click() {
            Print( this.title )
            doSomeThingA()
            doSomeThingB()
        }
    }
    // 私有属性，不能被外部访问
    dat Image(_width Int, _height Int, _source Str) {
        Init(w Int, h Int, s Str) Image {
            this._width, this._height, this._source = w, h, s
            ret this
        }
    }

    // Interface
    any Animation {
        Move(s Int)
        Stop()
    }

    // Combine Template
    dat Image_Button(as Image, as Button, title Str) {
        // Implement Interface
        Move(s Int) {
            t = 5000/s
            play( s + t )
        }
        Stop() {}

        Init(w Int, h Int) Image_Button {
            this.Image.Init(w, h, "img")
            this.title = "img btn"
            ret this
        }
    }

    // Create an Template object
    var ib = Image_Button(1, 2)
    ib = new(2, 1)
    // Calling property
    ib.title = "OK"
    // Calling method
    ib.Show()
    // Calling protocol
    ib.Move(6)

    // Use Interface
    fun play_animation(a Animation) do {
        a.Move(1000)
        a.Stop()
    }
    play_animation(ib)

    // Create an object with simple assign
    var ib2 = Image_Button(
        title = "Cancel",
        background = "red"
    )

    // Create an object with params
    var img = Image(30, 20, "./icon.png")
    var imgbtn = Image_Button().Init(1, 1)

    fun task(i Int) (r Int) do {
        // make a function to async
        ~> do_some_thing_A()
        // make channel
        var ch = Chan[Int](1)
        // await
        ch <~ i
        // await
        ret <~ ch
    }

    var x = task(6)

    // Annotation
    `table("user"), property(false, name = "d", hide = true)`
    dat User(
        `column("id"), required, key`
        id Str,
        `column("nick_name"), required)`
        nick_name Str,
        `column("time_update"), required)`
        time_update Int
    )

    // Optional obj
    var a ?Int = nil
    // Safe Call
    var e = a?.To_Str()
    // OrElseValue
    var f = a ?: 128

    // Reference
    fun swap(x ref Int, y ref Int) do {
        x, y = y, x
    }
    var a, b = 1, 2
    swap(ref a, ref b)
    
    // Generic Template
    obj Table[T](data T) {
        Set_data(d T) {
            data = d
        }
    }
    Table[Int](1)
    // Generic function
    fun Add[T](x1 T, x2 T) (r T) do {
        ret x1 + x2
    }
    Add[Int](1, 2)

    // Lambda Function
    arr.select(fun(it) do it > 2 )

    // Func params
    fun f(i fun(Int)Int) do {
        i(1)
    }
    f(fun(x Int) do {
        ret y
    })

    dat Color {
        case Red
        case Green
        case Blue
    }
    if x is dat { case Red case Green case Blue } do {}
    dat Unit case unit
    dat Bool {
        case False
        case True
    }
    dat List[A] {
        case Empty
        case Cons(head A, tail List(A))
    }
    dat Person(age Int, name Str)
    dat Man(as Person)
    dat Option[V] {
        case None
        case Some(v V)
    }
    dat Result[V] {
        case Failure(e Error)
        case Success(v V)
    }
    fun Function(age Int, name Str) do {}
    any fun toString() Str
    any {
        fun toString() Str
    }

    var op = Option[Int].None
    op = Option[Int].Some(1)
    op = new Some(1)
    if op == Some(var v) do {
        v
    }
    var int_op = dat{ case None case Some(v Int) }.Some(1)
    dat Foo()
    var foo = Foo()
    
    // operator override
    dat Complex(v Int, i Int) {
        // Complex + Complex
        Plus(x Complex) (r Complex) do {
            ret Complex(v + x.v, i + x.i)
        }

        // y = Complex.[x]
        Get(x Bool) (r Int) do {
            ret if x do v else do i
        }
        // Complex.[x] = y
        Set(x Bool, y Int) do {
            if x do v = y
            else do i = y
        }
    }
}
