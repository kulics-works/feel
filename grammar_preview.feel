` Grammar Overview `

` Export Name Space `
<- demo

` Import Name Space `
-> {
    System
    System.Linq
    System.Text
    System.Threading.Tasks
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    . = IO.File ` 可以隐藏元素使用内容 `
}

Main = () {
    ` Define, 一般情况下编译器会自动判断类型 `
    string = "10"   ` Str `
    number = 1.2    ` Num `
    integer = 123   ` Int `
    boolean = true  ` Bool `
    smallFloat = (1.2).To_F32() ` basic type convert `

    ` Const `
    PI = 3.141592653

    ` Mark String `
    format = "the value is \{integer}, \{number}, \{boolean}"

    ` Array `
    array : (Int)Array = Array_of(1, 2, 3)

    ` List `
    list : (Int)List = List_of(1, 2, 3, 4, 5)
    Print( list[0] ) ` 使用下标获取 `

    ` Dictionary, 前面为key，后面为value `
    dict : (Str, Bool)Dict = Dict_of( Pair_of("1", false), Pair_of("2", true))
    Print( dict["1"] ) ` 使用key获取 `

    ` Anonymous Template `
    new = $(title : Str, number : Int)$("nnn", 8)

    ` Function `
    fn = (in : Int -> out : Int) {} ` (Int->Int) `

    ` Function with no params no return `
    do_something_void = (->) {
        do_something_a()
        do_something_b()
    }

    ` Full Function with in params and out params `
    do_something_with_params = (x : Int, y : Str -> a : Int, b : Str) {
        <- x, y
    }

    ` Function can omit return type `
    funtion = (x : Int, y : Int) {
        <- x + y
    }

    do_something_void()
    ` 使用 _ 舍弃返回值 `
    _ = do_something_with_params(3, "test")

    ` Judge，当表达式的结果只有Bool时，相当于if，只当True时才执行 `
    1 + 1 <> 2 ? {
        do_something_a()
    }
    | ? {
        do_something_b()
    }

    1 + 1 <> 2 ? {
        Print(2)
    }
    | 2 + 1 > 3 ? {
        Print(3)
    }
    | ? {
        Print("else")
    }

    a, b = 1, 2 & a < b ? {
        do_something()
    }
    | c = 3 & a == c ? {
        do_something()
    }

    ` Judge type `
    ib :: Image_Button ? {
        ` Convert type `
        (ib ! View).show()
    }

    ` Switch `
    x == 
    | 1 | 2 | 3 ? {
        do_something()
    }
    | 4 ? {
        do_something()
    }
    | ? {
        do_something()
    }
    ` Match `
    x :: 
    | Int => it ? {
        do_something()
    }
    | Str => it ? {
        do_something()
    }
    | ? {
        do_something()
    }
    ` Complex Judge `
    x
    | @@ 0..6 | == 7 | == 8 | == 9 ? {
        do_something_a()
    }
    | == 14 ? {
        do_something_b()
    }
    | < 18 ? {
        do_something_c()
    }
    | > 18 & < 32 ? {
        do_something_d()
    }
    | :: Int ? {
        do_something_e()
    }
    | ? {
        do_something()
    }

    ` Loop, use identify to take out single item `
    array @ item {
        Print(item)
    }
    ` take index and value, both worked at Dictionary `
    array @ [index]value {
        Print(index, value)
    }

    ` Range, not close is "from .. to ~ step", close is "from ... to ~ step", "~ step" can omit `
    0 .. 100 @ it {
        Print(it)
    }
    10 ... 1 ~ -1 @ it {}

    ` Infinite `
    true @ {
        a > b ? {
            ~@  ` jump out loop `
        }
        @   ` continue `
    }
    ` Conditional `
    a = 0
    a < 10 @ {
        a += 1
    }
    | @ {
        ` Loop else `
    }

    a = 0 & a < 10 @ {
        a += 1
    }
    
    ` Check, listen the Exception Function `
    fi = open_file("./test.feel")
    f = read_file("demo.feel") & f ! {
        do_some_thing()
    }
    {
        do_some_thing()
    }
    & ex ! {
        ! <- ex ` Use ! <- to throw an Exception `
    }
    & ! {
        fi.dispose()
    }

    ` Template `
    View = $ (width : Int, height : Int, background : Str)

    ` 可以通过 me 来访问包自身属性或方法，当作为指针类型使用时 me 是指针，否则是值类型。 `
    Button = $ (
        width : Int,
        height : Int,
        background : Str,
        title : Str
    ) -> me {
        Click = () {
            Print( me.title )
            doSomeThingA()
            doSomeThingB()
        }
    }

    Image = $ (
        ` 私有属性，不能被外部访问 `
        _width : Int,
        _height : Int,
        _source : Str
    ) -> me {
        Init = (w : Int, h : Int, s : Str->v : Image) {
            me._width, me._height, me._source = w, h, s
            <- me
        }
    }

    ` Interface `
    Animation = $ {
        Move : (s : Int ->)
        Stop : (->)
    }

    ` Combine Template `
    Image_Button = $ (
        Image, ` delegate member `
        Button,
        title : Str
    ) -> me {
        ` Implement Interface `
        Move = (s : Int) {
            t = 5000/s
            play( s + t )
        }
        Stop = () {}

        Init = (w : Int, h : Int->v : Image_Button) {
            me.Image.Init(w, h, "img")
            me.title = "img btn"
            <- me
        }
    }

    ` Create an Template object `
    ib = Image_Button$()
    ` Calling property `
    ib.title = "OK"
    ` Calling method `
    ib.Show()
    ` Calling protocol `
    ib.Move(6)

    ` Use Interface `
    play_animation = (a : Animation) {
        a.Move(1000)
        a.Stop()
    }
    play_animation(ib)

    ` Create an object with simple assign `
    ib2 = Image_Button$(
        title = "Cancel",
        background = "red"
    )

    ` Create an object with params `
    img = Image$(30, 20, "./icon.png")
    imgbtn = Image_Button$().Init(1, 1)

    task = (in : Int -> out : Int) {
        ` make a function to async `
        ~> do_some_thing_A()
        ` make a function to await `
        do_some_thing_B~>()
        ` make channel `
        ch = (Int)Chan(1)
        ` await `
        ch <~ in
        ` await `
        <- <~ ch
    }

    x = task(6)

    ` Annotation `
    [table("user"), property(false, name = "d", hide = true)]
    User = $ (
        [column("id"), required, key]
        id : Str,
        [column("nick_name"), required]
        nick_name : Str,
        [column("time_update"), required]
        time_update : Int
    )

    ` Optional Type `
    a : Int? = nil
    ` Safe Call `
    e = a?.To_Str()
    ` OrElseValue `
    f = a ? 128

    ` Reference `
    swap = (x : Int@, y : Int@) {
        x, y = y, x
    }
    a, b = 1, 2
    swap(a@, b@)
    
    ` Generic Template `
    (T)
    Table = $ (data : T) {
        Set_data = (d : T) {
            data = d
        }
    }
    ` Generic function `
    (T)
    Add = (x1 : T, x2 : T -> y : T) {
        <- x1 + x2
    }

    ` Lambda Function `
    arr.select( (it){it > 2} )

    ` Func params `
    func = (in : (x : Int -> y : Int)) {
        in(1)
    }
    func( (x : Int -> y : Int) {
        <- y
    })

    Interface = $ {
        Receiver_function : (->)
        Member : (->)
    }
    Foo = $ (V1 : Int, V2 : Str) -> me {
        Member = () {}
        Receiver_function = () {}
    }
    a = Foo$(1, "123")
    a.Receiver_function()
    (T)
    Option = $ Some(T) | None {
        Member = () {}
        Receiver_function = () {}
    }
    b = Option$Some(1024)
    b = Option$None
    b.Receiver_function()

    Color = $ Red | Green | Blue

    ` operator override `
    Complex = $ (v : Int, i : Int) {
        ` Complex + Complex `
        Plus = (x : Complex->y : Complex) {
            <- Complex{ v = v + x.v; i = i + x.i }
        }

        ` y = Complex[x] `
        Get = (x : Bool->y : Int) {
            x ? {
                <- v
            }
            <- i
        }
        ` Complex[x] = y `
        Set = (x : Bool, y : Int->) {
            x ? {
                v = y
                <-
            }
            i = y
        }
    }
}
