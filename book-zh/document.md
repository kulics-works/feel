# Feel 编程语言
Feel 是一个专注于效率的开源编程语言，它可以帮你轻松构建跨平台软件。

通过精心设计的语法规则，这门语言可以有效降低读写负担，让你能够把真正的注意力放在解决问题上。  

## 关键特性
- 容易分辨、现代化的语法。
- 自动管理内存。
- 泛型。
- 多范式编程。
- 跨平台。
- Unicode。

# 目录
1. [安装与使用](#安装与使用)
1. [基础语法](#基础语法)
1. [基础类型](#基础类型)
1. [操作符](#操作符)
1. [集合类型](#集合类型)
1. [判断](#判断)
1. [循环](#循环)
1. [函数类型](#函数类型)
1. [结构体类型](#结构体类型)
1. [命名空间](#命名空间)
1. [接口类型](#接口类型)
1. [枚举类型](#枚举类型)
1. [检查](#检查)
1. [异步处理](#异步处理)
1. [泛型](#泛型)
1. [注解](#注解)
1. [可选类型](#可选类型)

# 安装与使用
目前 `Feel` 支持编译到 `C#/Kotlin`，因此需要在系统中安装 `DOTNET/JDK` 环境。  

执行编译器就会扫描当前文件夹的 `.feel` 文件，并且自动转译为同名的目标文件。  

我们需要使用部分语言库的功能，所以请自行引用编译器对应的库。

下载:
- [C#](https://github.com/kulics-works/feel-csharp/releases)
- [Kotlin](https://github.com/kulics-works/feel-kotlin/releases)

# 基础语法
## 基本语句
在这门语言内，任何表达都必须归属于语句。  

语句的基本形式为：
```
语句内容;
```
在本语言中，语法规则都是明确的，每一条语句都有明确的范围，必须由 `；` 或 `换行` 结束。
因此在大多数情况下，我们都可以直接使用换行来结束。只有特殊需求的时候，可以选择使用 `;` 来维持当前行。

所以我们更愿意这样写：
```
语句内容
语句内容
```
## 导出命名空间
本语言内所有的内容都只能定义在命名空间中，这样可以有效地将内容区分成明确的区块来管理，你可以在独立的命名空间中自由定义而不必过多受命名重复限制。  

我们可以使用 `# 名称` 语句来定义当前文件的命名空间。  

例如：
```
# Demo
```
这个语句的意思是将当前代码文件内的内容标记命名空间为 `Demo` ，这样里面的内容命名就被限定在区域内，不必考虑和区域外的命名冲突。  

同时外部区域可以导入 `Demo` 来使用其中的内容，我们接下来就会了解到如何导入。

## 导入命名空间
我们可以在导入语句`# {}`中，使用 `名称` 语句来导入其它的命名空间、库、框架到某个命名空间中。  

例如：
```
# Demo

# {
    System
}
```
这样就在 `Demo` 命名空间中导入了 `System` 库，然后就可以在程序中使用他们。

你可以编写多个导入语句，他们的顺序不影响导入功能。

更多关于命名空间的细节请查看[命名空间](#命名空间)

## 主入口
我们需要定义一个主入口来让程序知道从哪里启动。主入口通过一个函数 `Main := () {}` 声明。  

例如：
```
# Demo

# {
    System
}

Main := () {
}
```
这里的 主入口 函数是一个无参数无返回值的函数，它会被自动识别为主入口，程序启动时即会执行 主入口 函数，因此我们只需将功能写在 主入口 函数中即可。

在以后的示例中，我们默认都在 主入口 函数中执行，因此不再过多展示这部分代码。

特别的，一个命名空间内只能存在一个 主入口 函数，因为入口必须唯一。

关于函数的更多细节将在之后的章节中说明。
## 显示信息
我们使用程序都是为了获取到一些实际有用的信息，所以我们需要有显示信息给我们浏览的功能，这个功能可以是显示、打印或输出。

如果我们编写的是控制台程序，我们可以使用 `Print()` 函数，它可以将数据或文本信息显示到控制台供我们浏览。

例如：
```
Print("Hello world") // 输出 Hello world
```
在往后的例子中，我们都会使用控制台作为演示环境。
## 注释
注释只用来向使用者提供额外的信息，并不会被真正编译到可执行的程序中。

例如：
```
// 注释

/*
    复杂
    注释
*/
```

## 不变量
### 定义
不变量在这门语言中指的是在初始化后就不可更改的数据。我们使用 `标识符 : 类型` 来定义不变量。

**标识符必须大写开头**

例如：
```
A : Int
B : Bool
```
这会将左边的名称创建一个标识符，并且定义为右边的类型，此时这个标识符是一个空值。

一旦标识符被创建之后，它的数据类型在有效区域内就不会再被改变。
### 初始化
我们定义了不变量之后，赋值语句来进行初始化，不变量只能赋值一次。

和常规的编程语言一样，我们用 `标识符 = 值` 语句就可以将右边的数据赋值给左边的标识符。

例如：
```
A = 1
B = true
```

### 绑定
如果我们需要一次性定义并且初始化不变量，我们可以使用 `标识符 : 类型 = 值` 语句来进行绑定。

例如：
```
A : Int = 1
B : Bool = false
```

由于这门语言具有智能的自动推导功能，所以在值明确的时候，我们通常可以省略 `类型`。

例如：
```
A := 1
B := false
```

因为不变量一旦赋值后就无法修改，所以我们可以直接用赋值来绑定一个新不变量。

## 变量
### 定义
变量在这门语言中指的是在初始化后可以继续更改的数据。我们使用 `标识符 : 类型` 来定义变量。

**标识符必须小写开头**

例如：
```
a : Int
b : Bool
```
### 赋值
与不变量一样，变量也通过一样的赋值语句进行赋值，不同的是变量可以赋值多次。

例如:
```
a = 1
a = 2
b = false
b = true
```
 
### 绑定
与不变量一样，如果我们需要一次性定义并且初始化变量，我们可以使用 `标识符 : 类型 = 值` 语句来进行绑定。

例如：
```
a : Int = 1
b : Bool = false
```

同样的，我们可以继续使用自动推导。

例如：
```
a := 1
b := false
```

## 标识符
识符就是给变量、函数、结构体、接口等指定的名字。构成标识符的字母均有一定的规范，这门语言中标识符的命名规则如下：

1. 区分大小写，Myname与myname是两个不同的标识符；
1. 标识符首字符可以以下划线 `_` 或者字母开始，但不能是数字；
1. 标识符中其他字符可以是下划线 `_` 、字母或数字。
1. 在同一个 `{}` 内，不能重复定义相同名称的标识符。
1. 在不同 `{}` 内，可以定义重名的标识符，语言会优先选择当前范围内定义的标识符。
1. 大写开头的标识符是不可变的，小写开头的标识符是可变的。
1. 在命名空间、结构体和接口中，以下划线 `_` 开头的属性和方法名会被视为私有，其余会被视为公开。

# 基础类型
我们只需要一些简单的基础类型，就可以开展大部分工作。

## Integer 整数
由于我们目前的计算机结构比较擅长计算整数，因此一个独立的整数类型有助于提升程序的运行效率。

在本语言中，默认的整数为 `Int` 类型，它是一个 32 位有符号整数类型数据，是 `I32` 类型的别名，两者等价。

例如：
```
integer : Int = 3987349
```

如果我们需要其它数值范围的整数，也可以使用其它类型，所有支持的整数类型如下表。
```
I8          // 8位有符号  -128 到 127
U8, Byte    // 8位无符号  0 到 255
I16         // 16位有符号 -32,768 到 32,767
U16         // 16位无符号 0 到 65,535
I32, Int    // 32位有符号 -2,147,483,648 到 2,147,483,647
U32         // 32位无符号 0 到 4,294,967,295
I64         // 64位有符号 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
U64         // 64位无符号 0 到 18,446,744,073,709,551,615
```
## 基础类型转换
既然默认整数都是`Int`，我们怎么使用其它类型的整数呢？

我们可以用基础类型转换来将数字更改为我们需要的类型，只需要使用 `To_Type()` 方法即可。

例如：
```
integer8 := (16).To_I8()
```

## Float 浮点数
整数不能满足我们对数字的需求，我们很多时候还需要处理小数。

在本语言中，默认的小数为 `Num` 类型，它是一个 64 位双精度浮点型数据，是 `F64` 类型的别名，两者等价。

例如：
```
float1 : Num = 855.544
float2 : Num = 0.3141592653
```

需要注意的是，由于计算机计算浮点数的特殊性，浮点数运算存在一定的精度问题，所以对精度敏感的需求应该考虑特殊处理。

所有支持的浮点类型如下表：
```
F32         // 32位 ±1.5e−45 到 ±3.4e38
F64, Num    // 64位 ±5.0e−324 到 ±1.7e308
```
## Character 字符
计算机通常使用特定数字对字符进行编码显示，因此需要一种类型来表达字符，这个就是 `Chr` 类型。

它只能是单个字符，只代表了某一个字符与数字的对应关系，所以即是字符，也是数字。

你只需要使用 `''` 包裹一个字符，它就会被识别为字符值。

例如：
```
char1 : Chr = 'x'
char2 : Chr = '8'
```
## String 字符串  
我们在并不是生活在一个只有数字的世界，所以我们也非常需要使用文字来显示我们需要的信息。

在本语言中，默认的文字为 `Str` 类型，它是一个不限长度的字符串数据。

你只需要使用 `""` 包裹一段文字内容，它就会被识别为字符串值。

例如：
```
string : Str = "Hello world!"
```

需要注意的是，字符串是由多个字符组成的类型，所以实际上字符串是一个固定顺序的列表，两者存在对应关系。很多时候我们可以像使用列表那样对字符串进行处理。
## 字符串模版
很多时候我们需要将其它内容插入到字符串中，平常我们会如何做呢？

例如：
```
title   := "Year: "
content := 2018
string  := "Hello world! " + title + content.To_Str()
// Hello world! Year: 2018
```

这样做当然不影响功能，但是我们可以使用更直观方便的方式，那就是字符串模版。
我们可以使用 `\{表达式}` 语法直接插入表达式。

例如：
```
string := "Hello world! \{title}\{content}"
// Hello world! Year: 2018
```
## Boolean 布尔  
布尔指逻辑上的值，因为它们只能是真或者假。它经常用以辅助判断逻辑。

在本语言中，默认的布尔为 `Bool` 类型，它是一个只有真值和假值的类型。

例如：
```
boolean1 : Bool = true      ` 真 `
boolean2 : Bool = false     ` 假 `
```
## 任意类型  
特别的，有时候会需要一个可以是 任意对象 的 类型 来辅助完成功能，它就是 `Any` 。

例如：
```
a : Any = 1   // 任意类型
```

# 操作符
操作符是一种告诉编译器执行特定的数学或逻辑操作的符号。

我们可以简单地理解成数学中的计算符号，但是编程语言有它不同的地方。

## 算术操作符
算数操作符主要被使用在数字类型的数据运算上，大部分声明符合数学中的预期。

例如：
```
a := 4
b := 2
Print( a + b )    // + 加
Print( a - b )    // - 减
Print( a * b )    // * 乘
Print( a / b )    // / 除
Print( a % b )    // % 取余，意思是整除后剩下的余数，这里的结果为 2
Print( a ^ b )    // ^ 幂
```
除了数字之外，也有其它支持算术操作的类型，例如 `Str` 可以使用加运算将两段文字合并起来。

例如：
```
a := "hello"
b := "world"
c := a + " " + b     // "hello world"
```
## 判断操作符
判断操作符主要被使用在判断语句中，用来计算两个数据的关系，结果符合预期的为`true`，不符合的为`false`。

例如：
```
a := 4
b := 2
Print( a == b )     // == 等于
Print( a <> b )     // <> 不等于
Print( a > b )      // > 大于
Print( a >= b )     // >= 大于或等于
Print( a < b )      // < 小于
Print( a <= b )     // <= 小于或等于
```
## 逻辑操作符
逻辑操作符主要也被使用在判断语句中，用来进行逻辑运算（与、或、非）。

例如：
```
a := true
b := false
Print( a && b )     // && 与，两者同时为真才为真
Print( a || b )     // || 或，两者其中一者为真就为真
Print( ~~a )        // ~~ 非，布尔值取反
```
## 赋值操作符
赋值操作符主要用来将右边的数据赋值给左边的标识符，也可以附带一些快捷操作。

例如：
```
a := 1      // = 最简单的赋值
a += 1      // += 先相加再赋值
a -= 1      // -= 先相减再赋值
a *= 1      // *= 先相乘再赋值
a /= 1      // /= 先相除再赋值
a %= 1      // %= 先取余再赋值
a ^= 1      // ^= 先幂运算再赋值
```
## 位操作
位操作作为底层计算的基础，在本语言中也支持。

例如：
```
a := 1
a &&& 1      // 按位与
a ||| 1      // 按位或
a ^^^ 1      // 按位异或
~~~a         // 按位取反
a <<< 1      // 左移
a >>> 1      // 右移
```

# 集合类型
当我们需要将很多相同类型的数据组合在一起的时候，我们就可以使用集合来完成这个任务。

我们内置的集合类型有列表和字典两种。

## 列表
列表使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个列表的不同位置中。

### 定义
我们只需要使用 `List_of(表达式, 表达式)` 函数将我们需要的数据括起来，就可以创建一个列表。  
在大部分情况下，数据类型都可以由语言自动推断。

例如：
```
list := List_of(1, 2, 3, 4, 5)
```
这样便会创建一个包含 `1` 到 `5` 的 `Int` 类型列表。

如果你需要一个明确类型的列表，可以使用构造函数来创建。

列表类型的表示方法是 `List[元素类型]`。

例如我们需要一个字符串列表：
```
list : List[Str] = List_of[Str]()   // 空
```
### 访问
如果我们需要访问列表中的其中一个元素，我们可以用 `标识符.(索引)` 来访问。

例如：
```
Print( list.(1) )
```
需要注意的是，在编程语言里，大多数列表起始索引都是从 `0` 开始的，`标识符.(0)` 取得的才是第一个元素，往后的元素以此类推。
### 更改元素
如果我们需要更改列表中的其中一个元素，我们可以直接访问该元素，使用赋值语句来更改。

例如：
```
list.(0) = 5
```
需要注意的是，我们只能访问已经存在数据的索引，如果不存在，则会出现错误。
### 常用操作
```
list.Append(1)              // 添加到末尾
list.Insert(2, 3)           // 插入元素 3 到索引 2
list.Remove(1)              // 删除指定位置元素
length := list.Size()       // 长度
```
## 字典
字典是用来存储无序的相同类型数据的集合，字典每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。

和列表中的数据项不同，字典中的数据项并没有具体顺序。我们需要通过标识符（键）访问数据，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。

字典的键只能使用 `整数` 和 `字符串` 类型。
### 定义
和列表类似，字典使用 `Dict_of()` 定义，不同的是字典的类型是 `键` 和 `值` 的联合类型，形式是 `Pair_of(键, 值)`。

例如：
```
dictionary := Dict_of(Pair_of("a", 1), Pair_of("b", 2), Pair_of("c", 3))
```
这样便会创建一个包含 `a,b,c` 三个条目 的 `Dict[Str, Int]` 类型字典。

如果你需要一个明确类型的字典，同样可以使用构造函数来创建。

字典类型的表示方法是 `Dict[键类型, 值类型]`。

例如：
```
dictionary : Dict[Int, Int] = Dict_of[Int, Int]()     // 空
```
### 访问
和列表类似，我们也可以使用索引直接访问数据。

例如：
```
Print( dictionary.("a") )
```
### 更改元素
和列表类似，我们也可以使用赋值语句来更改元素。

例如：
```
dictionary.("b") = 5
```
和列表不同的是，如果赋值的是不存在的索引，也不会错误，会直接将值赋予给新的键。
### 常用操作
```
dictionary.("d") = 11        // 添加元素
dictionary.Remove("c")       // 删除指定索引元素
length := dictionary.Size()  // 长度
```

# 判断
判断语句通过设定的一个或多个条件来执行程序，在条件为 `true` 时执行指定的语句，在条件为 `false` 时执行另外指定的语句。

我们只需要使用 `? 表达式 {}` 就可以声明判断语句，根据后面的值进入对应的区域。

例如：
```
? true {
    Print("true")   // 真
}
```
## 简单判断
当判断值只会为 `Bool` 类型时，语句只有当为 `true` 时才执行。

如果需要 `false` 的情况，可以在后面使用 `| {}` 声明。

例如：
```
b = false
? b {
    ...... // 因为 B 为 false，所以永不会进入这个分支
} | {
    ...... // 处理 false
}
```

## 连续判断
如果我们有连续的条件需要判断，可以在中间插入连续判断语法 `| 表达式 {}`。

例如：
```
i = 3
? i == 0 {
    ......
} | i == 1 {
    ......
} | i == 2 {
    ......
} | {
    ......
}
```

## 连续单条件判断
如果我们需要对一个表达式进行多个连续相等判断，可以使用`| == 表达式 {}`语句。

例如：
```
? i == 0 {
    ......
} | == 1 {
    ......
} | == 2 {
    ......
} | {
    ......
}
```

是的，就像上面一样，这里的每一个条件被执行完成后都会被结束，并不会继续向下执行。

如果有多个条件需要合并一起，可以使用 `,` 分开。

例如：
```
? i == 1, 2, 3 {
    ......
} | == 4 {
    ......
}
```

这个语法可以支持所有的比较运算符。

例如：
```
? i <= 0 {
    ......
} | > 100 {
    ......
} | <> 500 {
    ......
} | {
    ......
}
```

# 循环
有的时候，我们可能需要多次执行同一块代码。

一般情况下，语句是按顺序执行的，函数中的第一个语句先执行，接着是第二个语句，以此类推。
## 集合循环
如果我们刚好有一个集合，可以是数组、字典、或是一段文本，那么我们就可以使用 `@ 标识符 := 表达式... {}` 语句来遍历这个集合，取出的每一个元素为 `标识符`。

例如：
```
arr := Array_of(1, 2, 3, 4, 5)
@ item := arr... {
    Print(item)
}
```

## 范围
有些时候，我们未必刚好就有一个集合，但是我们又需要从 `0` 到 `100` 去取数。我们有一些内置函数可以完成这样的任务。

例如：
```
@ i := 0.Up_to(100)... {
    Print(i)
}
```
需要注意的是，`0.Up_to(100)` 的意义是从 `0` 逐次读取到 `100` ，也就是一共执行了 `101` 次。迭代器会执行到最后一个数字被执行完毕，而不是提前一次结束。

默认每次间隔累加 `1`，如果我们需要每隔一个数取一次，可以增加一个每步条件。

例如：
```
@ i := 0.Up_to(100).Step(2)... {
    ......
}
```
这样每次间隔就不是 `1` 而是 `2` ，同理我们可以设置其它数字。

我们也可以让它倒序遍历。

例如：
```
@ i := 100.Down_to(0)... { // 从 100 到 0
    ......
}
```

如果我们需要忽略最后一位。

例如：
```
@ i := 0.Up_until(100)... { // 从 0 到 99
    ......
}

@ i := 100.Down_until(0)... {} // 从 100 到 1
```

## 条件循环
如果我们需要一个只判断某个条件的循环怎么做呢？
加一个条件就可以了。

例如：
```
i := 0
@ i < 6 {
    i += 1
}
```

## 跳出
那么要如何跳出循环呢？我们可以使用 `@ <-` 语句来跳出。

例如：
```
@ true {
    @ <-    // 什么都没执行就跳出了
}
```

需要注意的是，如果跳出在多层嵌套的循环中，只会跳出最靠近自己的那一层循环。
## 继续
如果只需要跳出当前循环，使用 `@` 语句即可。

# 函数类型
函数是用来完成特定任务的独立的代码块。

通常我们会将一系列需要重复使用的任务处理封装成为函数，方便在其它地方重复使用。

## 定义
之前我们已经见过了主入口函数，它只使用了固定语句 `Main := () {}` 来定义。

我们只需使用 `(->) {}` 搭配来定义一个函数。

例如：
```
function := (->) {
    ......
}
```
这样便定义了一个标识符为 `function` 的函数。 
## 调用
不像主入口函数不能被调用，常规函数都可以使用标识符来调用，我们只需要使用 `标识符()` 语句就可以使用封装好的函数。

例如：
```
function()
```
## 参数
虽然函数可以没有任何参数只执行特定的功能，但是更多时候我们需要的是可以接收某些输入数据、或是可以返回数据、或者两者都有的功能，而这需要参数出场来帮助我们完成任务。

非常简单的，我们只需要使用 `标识符 : 类型` 就可以声明参数。

例如：
```
func := (x : Int -> y : Int) {
    <- x * 2
}
```
这个函数的意义是，接受输入的一个 `Int` 参数 `x`，返回一个 `Int` 参数 `y`。

左边是入参，右边是出参，括号内的参数没有数量限制，但是对顺序和类型有严格要求。
### 返回
到这里，即使不明说，大致你也可以猜到 `<-` 应该是一个与返回有关的语句了。

是的，我们只需要使用 `<-` 就可以指定一个明确的返回语句。

例如：
```
<- 1, 2, 3, "Hello"
```
这会返回 `1, 2, 3, "Hello"` 四个值。

如果不需要返回数据，可以省略数据。

例如：
```
<-
```

如果是一个不需要返回值的函数，语言会自动在函数末尾添加退出功能，因此我们可以选择性省略部分返回语句。

我们可以在函数内的任何一个地方使用返回语句提前终止函数，这样可以满足我们对逻辑控制的需求。

需要注意的是，与循环的跳出一样，返回语句只会中止距离自己最近的一层函数。
### 入参
我们把输入进函数的参数称之为入参，入参可以没有或多个，对类型和标识符没有限制。

当我们调用函数时，需要按照定义好的顺序，将数据按顺序填入括号内。顺序或类型不符合时，都会被视为错误使用。

例如：
```
// 定义一个包含两个入参的函数
sell := (price : Int, name : Str ->) {
    ......
}
// 按照定义的要求，填入符合要求的数据
sell(1.99, "cola")
```
### 出参
和入参类似，出参也需要在定义时明确带有标识符，这能让调用者更容易获取函数的作用信息。

例如：
```
top_sell := (-> name : Str, count : Int) {
     <- "cola", 123
}
```
### 省略出参
当语言可以推断出返回值类型时，我们可以省略出参和`->`。

例如：
```
top_sell := () {
    <- "cola", 123
}
```

### 返回值的使用
那么我们如何获取一个函数的返回值呢？

很简单，就像我们做加减乘除运算一样去使用函数即可。

例如:
```
n, c := top_sell()        // 将返回的两个值赋值给 n 和 c
```
你可以使用定义或赋值语句去获得函数的返回值来使用，也可以将符合要求的函数嵌套到另一个函数里使用。

例如：
```
Print( top_sell() )      // 打印两个数值
```
## 函数入参
如果我们希望函数的部分细节由外部定义，内部只执行其余的部分逻辑，比如对某个集合遍历处理一些功能，这时我们可以使用函数入参来完成这个目标。

函数入参没有特别的定义方式，只是将参数的类型替换为函数，不需要定义函数执行内容，并且省略了标识符。

例如：
```
each_1_to_10 := (func : (Int->)) {
    @ i := 1.Up_to(10)... {
        func(i)
    }
}
```
我们定义了一个名为 `func` 的函数入参，它的类型是只有一个入参的函数。

这样我们就能将处理的细节交给外部传入的 `func` 定义了。

例如：
```
Show := (item : Int) {
    Print(item)
}

each_1_to_10(Show)
```
如此，我们就在 `each_1_to_10` 内部的循环中执行了 `Show`函数。

函数入参只要求函数的参数类型相同，不要求参数的命名相同。

## Lambda 表达式
如上面那种方式先定义一个函数再传入使用有时候显得比较啰嗦，因为我们仅仅只是希望执行一小段功能而已，未必想定义一个函数提供给其它地方使用。

这时我们可以使用 Lambda 表达式 的语法来简化我们的代码。

因为函数入参在声明时就已经确定了，所以我们可以使用简化的语法 `(标识符){语句}` 来表达，它的意思是定义入参标识符，执行函数语句。

例如：
```
foreach( (it) { 
    Print(it)
    Print(it * it)
    Print(it / 2)
})
take( (a, b) {a + b} )
```
非常简单，和函数类型的表达的差异在于，只需要声明参数标识符和执行逻辑，类型与返回值都不需要声明。

## Lambda 函数
与上面的简化写法不同，我们也可以直接写入一个完整的函数，就像我们定义函数一样。

例如：
```
each_1_to_10( (item : Int ->) {
    Print(item)
})
```

# 结构体类型
如果我们只有那几种基础数据，实际上非常难以描述更具体的东西。

因此我们需要一种，能将不同属性的数据包装起来的功能，才能更好地描述我们需要的东西。

显而易见，这个负责包装数据的功能，就是结构体。
## 定义
我们可以使用 `标识符 := $() {}` 语句来定义一个什么都没有的结构体。

例如：
```
Package := $() {}
```
当然，我们更希望的是能包装几个数据，例如一个具有名称、学号、班级、年级属性的学生。
我们可以像定义普通标识符一样在结构体内去定义这些数据。

例如：
```
Student := $(
    name   : Str,
    number : Str,
    class  : Int,
    grade  : Int
) {}
```
这样我们就得到了具有这几个数据属性的学生结构体。这个结构体现在就像 `Int, Str, Bool` 一样成为了一个可以使用的类型。

不像我们原始的基础类型只能存储一种数据，这个结构体可以同时存储名称、学号、班级、年级这些数据。

这非常像是我们现实中将不同的零件拼装在一起包装成一个整体的概念。

## 创建
那么我们怎么创建一个新的结构体呢？老样子，我们所有的类型都可以使用构造器 `类型$()` 来创建。

例如：
```
peter := Student$("", "", 0, 0)
```
这样便创建了一个 `peter` 标识符，这个学生的所有属性都被初始化为 `"", "", 0, 0` 。

让我们回顾一下，我们的基础类型、集合类型都可以使用构造方法来创建，实际上它们都是结构体.

## 使用属性
现在我们已经有了一个 `peter` ，我们要怎么使用里面的属性呢？

很简单，我们只需要使用 `.` 语法，就能召唤出我们需要的属性。

例如：
```
Print( peter.name )      ` 打印了某个学生的名字 `
```
要更改属性的值也是一样的，它就相当于是个嵌套的标识符。我们可以直接用赋值语句去更改值。

例如：
```
peter.name      = "peter" 
peter.number    = "060233"
peter.class     = 2
peter.grade     = 6
```
## 构建赋值
像上面那样创建一个新的结构体，再逐个装填数据非常麻烦，我们可以使用简化语法来配置。  

例如：
```
peter := Student$(
    name    = "peter",
    number  = "060233",
    class   = 2,
    grade   = 6
)
```

## 匿名结构体
如果我们只想直接包裹某些数据使用，而不是先定义结构体再使用，像匿名函数那样可以吗？

当然可以的。

例如：
```
peter := $(name, number, class, grade){}$("peter", "060233", 2, 6)
```

这样就直接创建了一个 `peter` 数据，我们可以直接使用这些数据。

## 私有属性
任何人都会有些小秘密，`peter` 也一样，也许他藏了一个秘密小女友的名字不想让其他人知道。

我们可以定义私有属性来存储一些不想被外界访问的属性。

例如：
```
Student := $(
    ......
    _girl_friend : Str // 第一个字符是 _ 的标识符是私有的
) {}
```
没错，如果你还记得标识符的定义的话，这就是私有标识符的定义方式，私有标识符是不能被外界访问的。

因此我们再定义一个 `peter` 的话，也不能通过 `peter._girl_friend` 来获取值或修改值。

那这种结构体的私有属性又不能访问，又不能修改，有什么用呢？别急，我们可以用函数来操作。

例如：
```
Student := $(
    ......
) {
    Get_girl_friend := () {
        <- this._girl_friend
    }
}
```

这里的 `this` 用来声明结构体自身，这样可以方便地访问自身的属性。

通过函数属性，我们就能获取到私有的属性，也可以方便地根据业务需求去处理结构体中的其它数据。

有了这个函数，我们就可以通过调用函数去获取私有属性了。

例如：
```
Print( peter.Get_girl_friend() ) 
```
与数据属性一样，函数也可以是私有标识符，使用私有标识符的函数也意味着只有结构体自己能访问。

## 组合
现在让我们发挥我们的想象力，我们想要一个专门给中国学生定制的结构体该怎么定义呢？

例如：
```
Chinese_Student := $(
    name    : Str,
    number  : Str,
    class   : Int,
    grade   : Int,
    kungfu  : Bool
) {}
```
不不不，这样重复定义数据就很不优雅了，我们可以将学生属性复用，加上一个额外的功夫属性就可以了。

我们需要用到组合这个特性，但是没有那么复杂，只是创建了一个学生属性而已。

例如：
```
Chinese_Student := $(
    student : Student, // 将学生属性包含其中
    kungfu  : Bool
) {}
```
这样你就可以通过中国学生里的学生属性来使用通用属性。

例如：
```
chen := Chinese_Student$(Student$("", "", 0, 0), false)
Print( chen.student.name )
```
通过组合一层又一层的结构体，你可以自由拼装出任何一个你想要描述的事物。

更近一步，如果我们希望直接包含某个结构体的所有属性而不是组合，可以使用顶层组合语句，声明方式为`类型`。

顶层组合会将结构体内的属性提取到最外部，就像直接包含对应属性一样。这有利于我们实现属性使用和传递。

例如：
```
Chinese_Student := $(
    super  : Student,
    kungfu : Bool
) {
    super // 顶层组合
}
```

这样我们就可以直接调用学生属性。

例如：
```
chen := Chinese_Student$(Student$("", "", 0, 0), false)
Print( chen.name )
```

# 命名空间
命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的名称与另一个命名空间中声明的名称不冲突。

## 导出
为了方便我们管理代码，我们必须将我们的代码写在命名空间内，我们可以通过公有属性暴露给外部使用，也可以使用私有属性只完成自己的业务。

例如：
```
# Name.Space

get_something := () {
    <- "something"
}
```
## 导入
我们可以通过导入功能来使用其它命名空间内容，导入后可以直接调用命名空间内容。

例如：
```
# Run

# { 
    Name.Space 
}

Main := () {
    Print( get_something() )
}
```

# 接口类型
我们在现实中常常用协议来规定一些特定的规则，让人或事物可以按照预期的规则来做事情。
我们在程序语言里也常常需要这么做，这个功能就是接口。

接口用来规定某一特定功能所必需的函数，只要一个结构体包含一个接口所要求的所有函数，就认为结构体实现了接口。

## 定义
接口直接使用 `$ {}` 定义，与结构体不同是它没有构造器。

例如：
```
Protocol := $ {}
```

接下来，让我们设计一个学生都需要完成的艰巨任务……作业。

例如：
```
Homework := $ {
    Get_count : (->v : Int)
    Do_homework : (->)
}
```
这是一个作业接口，它有两个函数，一个获取作业的数量，一个完成作业。

接下来，我们就要让学生来实现这个接口了。
## 实现接口
我们直接给结构体增加函数来实现这个接口。

例如：
```
Student := $(count : Int) {
    Get_count := () {
        <- this.count
    }
    Do_homework := () {
        Spend_time(1)   // 花费了一个小时
        this.count -= 1 // 完成了一个
    }
}
```
我们的学生写作业真是非常艰苦的……

让我们来解释一下这段代码发生了什么：
1. 我们实现了一个接口，现在 `Student` 也被认为是 `Homework` 类型了，我们可以将一个 `Student` 当作 `Homework` 一样去使用。
1. 在接口内我们包含了接口规定的两个属性 `Get_count, Do_homework` ，根据规定，一个也不能少。
1. 我们给接口的两个属性都分别编写了真实的值和函数，这样这两个属性就成为了 `Student` 的有效子属性之一。
1. 我们在 `Do_homework` 里面做了一些事情，减少了作业的总量。

## 使用接口
包含了接口之后，我们就能使用拥有接口的学生了。

例如：
```
peter := Student$(999999)
Print( peter.Get_count() )  // 打印 999999，好多呀
peter.Do_homework()         // 做了一次作业
Print( peter.Get_count() )  // 打印 999998，还是好多呀
```
如果只是这样使用，那和在结构体里直接定义这两个属性比就没什么优势了。

让我们来回想一下接口的作用，接口是让每个含了接口的结构体都拥有了规定的相同的属性。

这样对于接口的制定者来说，就无需关心结构体是如何遵循接口的，只需要知道它们都遵循了，就能用同样的方法去使用它们。

现在我们可以创建各种各样的学生，它们都遵循了一样的接口，我们可以无差别使用接口里的功能。

例如:
```
// 创建了三个不同类型的学生结构体
student_a := Chinese_Student$(32)
student_b := American_Student$(32)
student_c := Japanese_Student$(32)
// 让他们分别做作业
student_a.Do_homework()
student_b.Do_homework()
student_c.Do_homework()
```
更有效率的做法是把这个功能写进函数，让函数来帮我们重复调用接口的功能。

例如：
```
do_homework := (student : Homework) {
    student.Do_homework()
}
// 现在我们就可以更简单地让每个学生做作业了
do_homework(student_a)
do_homework(student_b)
do_homework(student_c)
```
当然，更好的做法是把这些学生都放进数组，这样我们就可以使用循环来处理这些重复的工作了。

例如：
```
arr := List_of[Homework](......)
@ i := arr... {
    do_homework(i)
}
```
╮（￣▽￣）╭  
完美

## 类型判断
因为结构体类型可以被转为接口类型使用，所以在使用过程中就不能确定数据的原始类型。

但有时候我们又需要获得数据的原始类型来处理，我们可以使用类型判断来帮助我们完成这个事情。

我们可以使用 `表达式 :: 类型` 来判断数据的类型，使用 `表达式.[类型]` 来将数据转化为我们的类型。

例如：
```
func := (he : Homework) {
    // 判断是否中国学生
    ? he :: Chinese_Student {
        // 转换为中国学生数据
        cs := he.[Chinese_Student]
    }
}
```

# 枚举类型
枚举是一组具有独立名称整数常量。通常可以用来标记一些业务数据的类型，方便判断处理。
## 定义
我们只需要使用 `$[] {}` 语句即可。

例如：
```
Color := $[Red, Green, Blue] {}
```
枚举会按照顺序给标识符赋值，最终得到 `Red = 0, Green = 1, Blue = 2` 这样的集合。

这样我们在使用时就无需关心它们的数值，放心标记我们需要处理的业务。

例如：
```
c := Color$Red     // 获取一个颜色
? c == $Red {
    ......
} | == $Green {
    ......
} | == $Blue {
    ......
}
```

需要注意的是，枚举只能在命名空间下定义。
## 指定值
如果有需要，我们也可以给单独一个标识符赋值，没指定的会依照上一个标识符顺序继续累加1。

例如:
```
Number := $[
    A = 1,  // 1
    B,      // 2
    C = 1,  // 1
    D       // 2
] {}
```

# 检查
程序可能会出现各种各样的异常。

- 可能是文件或者用户输入的内容导致的。
- 可能是编码错误或语言中缺少的功能。
- 当然，也可能是由于许多其他不可预知的因素。

异常无法完全避免，但是我们可以选择一些手段帮助我们检查和报告异常。

## 报告异常
我们可以在函数中的任何地方，使用 `! <- 异常` 来声明一个异常数据。

例如：
```
read_file := (name : Str) {
    ? name.Size() == 0 {
        ! <- Exception$("something wrong")
    }
    ......
}
```
这样我们就声明了一个异常，异常说明是 `something wrong`，一旦外部调用者使用了不合法长度的 `name`，这个函数就会被强制中止，将这个异常向上报告，交给调用者处理。
## 检查异常
我们可以使用 `! {}` 语句来检查异常，使用 `| :: 类型 => 标识符 {}` 来处理异常。
`:: 类型`可以省略，默认为`Exception`。   

例如：
```
! {
    f := read_file("temp.txt")
} | :: IO_Exception => ex {
    ! <- ex
} | => e {
    Print(e.message)
}
```
当出现异常时，程序就会进入错误处理区块，`e` 为异常标识符，我们可以获取异常的信息，或者进行其它操作。

如果没有异常，则不会进入异常处理区块的逻辑。

一般情况下，我们可以在异常处理中进行提早返回或数据处理，如果有处理不了的异常，我们也可以继续向上报告。

例如：
```
! {
    func()
} | => ex {
    ! <- ex
}
```

## 检查延迟
如果我们有一段功能希望无论程序正常或异常都能处理，例如关键资源的释放问题，我们可以使用检查延迟特性。

很简单，在检查的最后使用 `& {}` 就能声明一段检查延迟的语句。

例如：
```
func := () {
    f : File
    ! {
        f = read_file("./somecode.file")
    } & {
        ? f <> nil {
            f.Release()
        }
    }
}
```
这样我们就声明了 `f.Release()` 这条释放文件的语句，这条语句不会被立刻执行，而是会等待检查结束后调用。

有了检查延迟，我们就可以无需关心如何退出，安全地处理某些任务。

需要注意的是，正因为检查延迟是函数退出前执行的，并且无论程序运行状态异常与否都会执行，所以检查延迟中不能使用返回语句。

例如：
```
......
& {
    f.Release()
    <-  // 错误，不能使用返回语句
}
```

# 异步处理
线程 被定义为程序的执行路径。每个线程都定义了一个独特的控制流。如果您的应用程序涉及到复杂的和耗时的操作，那么设置不同的线程执行路径往往是有益的，每个线程执行特定的工作。  

由于计算机处理器是有计算瓶颈的，所以无法让所有的事情都按照单线顺序的方式逐个处理，为了提升处理容量，我们经常会需要使用异步并行的方式来解决计算问题。  

这里我们谈一谈如何更简单地处理线程问题，也就是异步处理。  

## 异步执行
那么如何将一个同步函数转化为异步函数呢？使用 `~>` 就可以了。

没错，真的是使用 `~>` 就可以了。

例如：
```
say_hello := () { 
    Print("hello")
    <- 2020
}

~> say_hello()
```

将一个同步函数转化为异步函数后，它就会被转移到一个新的线程中执行。这使得我们的逻辑可以并行处理，但同时也使得我们无法直接获得这个函数的返回值，因为函数执行结束的时间变得不再受我们控制，当前逻辑不会等待异步函数，而是会继续执行。

所以以下的代码是无法通过的。

例如：
```
result := ~> say_hello()
// 错误，当前逻辑会继续执行，无法直接获得返回值
```

## 异步等待
如果我们需要将一个同步函数转化为异步函数，同时又希望当前逻辑能够等待这个函数执行结束，用类似同步的方式编写异步代码是否可以呢？

答案是可以的，我们可以使用一个别致的语法`function~>()`来执行一个同步函数，这个函数不仅会被异步执行，同时当前程序也会等待它完成后才继续向下执行。

使用这种方式，我们就可以得到我们想要的结果了。

例如：
```
result := say_hello~>()
// 正确，当前逻辑会等待异步结果，然后再继续执行
```

## 使用通道异步通信
对于直接的瀑布式逻辑，以上的语法已经可以满足我们的使用了。但是还有另一一些场景，我们可能需要手动处理更多异步细节，这时我们可以使用通道来传递数据，来完成我们的异步任务。

通道是一种特殊的集合，类型为 `Chan[元素类型]`，我们可以向通道中传递指定类型的数据，使用 `id <~ value` 来输入数据，使用 `<~ id` 来获取数据。

例如：
```
channel := Chan[Int]$()

// 当前逻辑会等待数据传递完成后再继续执行
channel <~ 666

// 同样的道理，获取数据也会暂停当前逻辑
Print(<~ channel)
```

有了通道，我们就可以通过简单的组装实现异步编程了。

例如：

```
ch := Chan[Int]$()

// 执行一个并发函数
~> () {
    @ i := 3.Down_to(0)... {
        ch <~ i
    }
}()

// 循环接收通道数据
@ true {
    data := <~ ch
    Print(data)
    // 当遇到数据0时, 退出循环
    ? data == 0 {
        @ <-
    }
}
// 输出 3 2 1 0
```

既然通道是集合类型，我们也可以使用遍历语法。

例如：
```
@ data := ch... {
    Print(data)
}
```

# 泛型
在封装公共组件的时候，很多时候我们的结构体、函数、接口不需要关注调用者传递的实体是"什么"，这个时候就可以使用泛型。  

比如我们现在需要一个集合，可以支持增加、删除和读取，希望任何类型都可以使用，就可以封装一个泛型的结构体。 

我们的列表和字典其实就是使用泛型实现的。

## 声明与使用
让我们来看看怎么使用泛型来实现一个列表，我们只需使用 `[泛型标识符]` 来声明类型的代称即可。

这是一个简化的实现。

例如：
```

MyList := [T]$(
    items  : Storage[T],
    length : Int
) {
    // 获取某个泛型数据
    Get := (index : Int -> item : T) {  
        <- items.Get( index )
    }

    // 将一个泛型数据添加进列表
    Append := (item : T) {   
        items.Insert(length - 1, item)
        length += 1
    }
}
```
这样我们便定义一个支持泛型的结构体，`T` 就是泛型，实际上它可以是任何标识符，只是习惯性我们会使用 `T` 作为代称。

泛型内支持多个代称，例如：`[T, H, Q]`。

定义了泛型之后，在结构体的区域内，就会将 `T` 看作是真正的类型，之后我们可以像 `Int` 一样在各种需要类型的地方使用它。

那么我们如何使用泛型呢？

很简单，就和我们声明一样去使用即可，只不过调用时需传入真正的类型。

例如：
```
int_list := MyList[Int]$(......)      // 传入 Int 类型
```
这样我们便拥有了一个整数类型的列表，是不是很像这个：
```
int_list := List_of[Int]()
```
没错，其实我们的列表和字典语法都是泛型。
## 支持的类型
我们可以在 结构体、函数、接口 类型中使用泛型。

例如：
```
Func := [T](data : T -> data : T) {
    <- data
}

Interface := [T]$ {
    Test : [R](in : T -> out : R)
}
```
## 泛型约束
如果我们需要对泛型的类型进行约束，只需要使用 `[T:约束]` 语法即可。

例如：
```
StudentGroup := [T:Homework]$() {}
```

# 注解
注解是用于在运行时传递程序中各种元素（比如结构体、函数、组件等）的特征信息的声明性标签。
通常我们在很多反射、数据解析的场景种会使用到注解特性。

## 注解声明
我们只需要使用 ``` `` ```。
如果需要注明指定属性，则如结构体的简化构建一样使用 `标识符 = 表达式` 赋值即可。

注意要在标识符前面使用才有效。

下面我们以数据库数据为参照看看要如何使用注解。

例如：
```
`Table("test")`
Annotation := $(
    `Key, Column("id")`
    id : Str,
    `Column("name")`
    name : Str,
    `Column("data")`
    data : Str
) {}
```
我们声明了一个 `Annotation` 的结构体，它使用注解标记了表名 `test`、主键 `id`、字段 `name` 和字段 `data`。

这样在处理数据库时，就可以被数据库接口解析为对应的名称来进行数据操作了。

我们在程序内部直接使用这个结构体，调用数据库功能时程序会自动映射为对应数据库数据。
这样极大节省了我们进行解析转换的工作。

# 可选类型
本语言中所有的类型默认都不可以为空值，这可以极大限度地避免空值问题。
如果定义了一个类型却并未赋值，那么它将不能被使用。

例如：
```
a : Int
b := a       // 错误，并未给 a 赋值
```

## 声明与使用

如果某些情况必须要使用带空值地类型，可以使用可空类型。
只需要在非空类型前加入`?`，即为可空类型。

例如：
```
a : ?Int
b := a       // b 赋值为空的 Int
```

## nil 空 
我们需要一个可以是 任意类型空值 的 值 ，所以它就是 `nil` 。

例如：
```
a = nil     ` 空值 `
```

一旦出现了可选类型，我们就需要严格处理空值，避免程序错误。

例如：
```
? a <> nil {
    a.To_Str()
}
```

这样做很繁琐，特别是我们需要执行连续多个函数的时候。  
我们可以在表达式后面加上 `?` 来使用它们，这样只有当他们不为空时才会执行。

例如：
```
arr?.To_Str()
```

## 合并操作
如果希望可选类型的值为空时选用另一个默认值，可以使用 `id ?| value`。

例如：
```
b := a ?| 128
```

## [完整示例](../example.feel)