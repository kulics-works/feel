# 包
如果我们只有那几种基础数据，实际上非常难以描述更具体的东西。

因此我们需要一种，能将不同属性的数据包装起来的功能，才能更好地描述我们需要的东西。

显而易见，这个负责包装数据的功能，就是包。
## 定义
我们可以使用 `id {}-> {}` 语句来定义一个什么都没有的包。

例如：
```
Package {}->
{
}
```
当然，我们更希望的是能包装几个数据，例如一个具有名称、学号、班级、年级属性的学生。
我们可以像定义普通标识符一样在包内去定义这些数据。

例如：
```
Student {}->
{
    Name :str = ""
    Number :str = ""
    Class :i32 = 0
    Grade :i32 = 0
}
```
这样我们就得到了具有这几个数据属性的学生包。这个学生包现在就像 `i32,str,bool` 一样成为了一个可以使用的类型。

不像我们原始的基础类型只能存储一种数据，这个学生包可以同时存储名称、学号、班级、年级这些数据。

这非常像是我们现实中将不同的零件拼装在一起包装成一个整体的概念，因此它就被称之为包。

## 创建
那么我们怎么创建一个新的包呢？老样子，我们所有的类型都可以使用类型创建语法来创建。

例如：
```
Peter := Student.{}
```
这样便创建了一个 `Peter` 标识符，这个学生的所有属性都根据定义中设置的那样被初始化为 `"","",0,0` 。

让我们回顾一下，我们的基础类型、集合类型都可以使用类型创建语法来创建，实际上它们都是包。

只要是由包扩展出来的类型，都可以一样使用创建语法来创建，这在这门语言里是一个定则。

## 使用属性
现在我们已经有了一个 `Peter` ，我们要怎么使用里面的属性呢？

很简单，我们只需要使用 `.` 语法，就能召唤出我们需要的属性。

例如：
```
Console.WriteLine.( Peter.Name )      // 打印了某个学生的名字
```
要更改属性的值也是一样的，它就相当于是个嵌套的标识符。我们可以直接用赋值语句去更改值。

例如：
```
Peter.Name = "Peter" 
Peter.Number = "060233"
Peter.Class = 2
Peter.Grade = 6
```
## 简化创建
像上面那样创建一个新的包，再逐个装填数据非常麻烦，我们可以使用简化语法来配置。
只要在创建语法后面加上`...`就能使用`key=value`方式来快捷装填数据了，多个数据用`,`隔开。

例如：
```
Peter := Student.{
    ...Name="Peter", Number="060233",
    Class=2, Grade=6
}
```

这样手指就没那么酸了啊。

同样的，集合的创建方式其实就是一种简化创建，所以我们也可以这样创建数组和字典。

例如：
```
Array := []i32.{ ...1, 2, 3, 4, 5 }
Dictionary := [str]i32.{ ..."1"->1, "2"->2, "3"->3 }
```
## 匿名包
如果我们只想直接包裹某些数据使用，而不是先定义包再使用，像匿名函数那样可以吗？

当然可以的，我们直接使用`_`就可以了。

例如：
```
Peter := _
{
    Name := "Peter"
    Number := "060233"
    Class := 2
    Grade := 6
}
```

这样就直接创建了一个`Peter`数据，我们可以直接使用这些数据，但是不可更改这些数据。

由于匿名包并不是一个具有明确类型的包，所以我们只建议在一些临时场合使用，例如LINQ。

## 私有属性
任何人都会有些小秘密， `Peter` 也一样，也许他藏了一个秘密小女友的名字不想让其他人知道。

我们可以定义私有属性来存储一些不想被外界访问的属性。

例如：
```
Student {}->
{
    ...
    _GirlFirend :str // 第一个字符是 _ 的标识符是私有的
}
```
没错，如果你还记得标识符的定义的话，这就是私有标识符的定义方式，私有标识符是不能被外界访问的。

因此我们再定义一个 `Peter` 的话，也不能通过 `Peter._GirlFirend` 来获取值或修改值。

那这种包的私有属性又不能访问，又不能修改，有什么用呢？别急，包还有另外一种属性。

## 扩展函数
如果我们需要让这个包自带函数，让它能方便操作，我们不能在包内直接定义。
我们需要使用扩展语句`id += {}来使包增加扩展函数。

例如：
```
Student += 
{
    GetGirlFirend ()->(name:str)
    {
        <- (.._GirlFirend)
    }
}
```
因为扩展函数属于包的一部分，而函数是可以调用数据或功能的，这样我们就可以定义一个获取获取私有属性的方法。

这里的 `..` 用来声明包自身，这样可以方便地访问自身的属性。这可以认为是其它语言中的 `this | self` 。

通过函数属性，我们就能获取到私有的属性，也可以方便地根据业务需求去处理包中的其它数据。

有了这个函数，我们就可以通过调用函数去获取私有属性了。

例如：
```
Console.WriteLine.( Peter.GetGirlFirend.() ) 
// 打印了某个早恋学生的女朋友名字
```
与数据属性一样，函数也可以是私有标识符，使用私有标识符的函数也意味着只有包自己能访问。

## 构造
有些时候，我们并不希望总是反复创建数据为空的学生，实际上学号中经常已经包含了年级和班级的相关信息，

我们希望只要给定名字和学号，班级和年级信息就会自动被准确创建。

这可以使用常规函数来实现，但是为什么不用包自带的构造函数呢？

在定义的时候加入参数，并且写好构造函数的定义，这只需要 `.. {}` 语句就可以办到。

例如：
```
Student {name, number:str}->
{
    ...
    
    ..
    {
        ..Name = name
        ..Number = number
        // 计算得出班级
        ..Class = GetSubText.(number, 2, 3)
        // 计算得出年级
        ..Grade = GetSubText.(number, 0, 1)
    }
}
```
这样就得到了一个带构造函数的包，我们在创建一个新学生的时候，就会自动产生班级和年级数据。

例如：
```
Peter := Student.{"Peter", "060233"}
Console.WriteLine.(Peter.Class)     // 打印出 2
```

如果需要同时使用构造函数和简化创建，可以这样做。

例如：
```
Peter := Student.{"Peter", "060233" ... Name="New Peter"}
```

需要注意的是，一个包只能支持一个构造函数，我们建议保持构造的简单性，一个稳定的包更容易被调用者放心使用，

如果真的有更多构造需求，可以使用常规函数来完成这个需求。
## 组合
现在让我们发挥我们的想象力，我们想要一个专门给中国学生定制的数据包该怎么定义呢？

例如：
```
ChineseStudent {}->
{
    Name :str = ""
    Number :str = ""
    Class :i32 = 0
    Grade :i32 = 0
    KungFu :bool = false     // 不会功夫的学生
}
```
不不不，这样重复定义数据就很不优雅了，我们可以将学生属性复用，加上一个额外的功夫属性就可以了。

我们需要用到组合这个特性，但是没有那么复杂，只是创建了一个学生属性而已。

例如：
```
ChineseStudent {}->
{
    Student :Student?   // 将学生属性包含其中
    KungFu :bool?       // 不会功夫的学生
}
```
这样你就可以通过中国学生里的学生属性来使用通用属性。

例如：
```
Chen := ChineseStudent.{}
Console.WriteLine.( Chen.Student.Name )
// 当然，因为没有赋值，所以没有什么也没输出
```
通过组合一层又一层的包，你可以自由拼装出任何一个你想要描述的事物。

### 

## 本章示例
```
Demo
{
    .. System

    Main ()
    {
        a := S.{...A=5,B=12}
        b := PKG.{"hello", 64, a}
        Console.WriteLine.( b.Z.A )
        Console.WriteLine.( b.Print.() )
    }

    S {}->
    {
        A := 0
        B := 0
    }

    PKG {x:str,y:i32,z:S}->
    {
        X := ""
        Y := 0
        Z := S.{}

        ..
        {
            X = x
            Y = y
            Z = z
        }
    }

    PKG +=
    {
        Print ()->(a:str)
        {
            <- ( /"X {Y}"/ )
        }
    }
}
```


[下一章](协议类型.md)