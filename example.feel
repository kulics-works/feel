# example

# {
    System
    System.IO
    System.Collections.Generic
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    System.Threading.Tasks

    example.example_static => .
}

/*
   // main function
*/
fun Main() do {
    Print("main function")
    // run test
    Test_type()
    Test_operator()
    Test_string()
    Test_optional()
    Test_list()
    Test_dict()
    Test_switch()
    Test_if()
    Test_foreach()
    Test_while()
    var X = Test_func("testcall")
    Test_func_params(a = 1, b = 2,
    fun(a Int, b Int, c Int, d Int) do {
        ret "", a, b, c
    })
    Test_check()
    Test_type_convert()
    Test_lambda()

    var Y = Test_tuple(1).To_Str()

    var P = example.App$()

    P.C(1)
    Test_interface(P)

    P.Test_func_template[Int, Str](1, "2").Test_package()
    
    for true do break
    
    if 1 == 1 do Print("test exception expression")
    
    Read()
}

`get, set`
var static_x = 0

`get, set`
var static_y = "hello"

var static_g Int = 3

fun Test_tuple(i Int) (v Str) do {
    ret "tuple"
}

fun Test_type() do {
    var I1 I8 = 1              // sbyte
    var I2 I16 = 1             // short
    var I3 I32 = 1             // Int
    var I4 I64 = 1             // long
    var U1 U8 = 1              // byte
    var U2 U16 = 1             // ushort
    var U3 U32 = 1             // uint
    var U4 U64 = 1             // ulong
    var F1 F32 = 1             // float
    var F2 F64 = 1             // double
    var Char1 Chr = 'a'        // char
    var String1 Str = "123"    // string
    var Bool1 Bool = false     // bool
    var Int1 Int = 1           // Int
    var Num1 Num = 1.0         // double
    var Byte1 Byte = 1         // byte
    var Any1 Any = 1           // object
}

fun Test_operator() do {
    var i Str = "128.687"
    i += ".890"
    var A = 003.141592653e3
    var b Int
    b = 2020_01_16
    b = 0b1010_1101
    b = 0X56_fa_C4
    b += Const_data
    b = + - b
    b = b + 1
    b = b * 2
    b = b / 2
    b = b % 2
    b = (b ^ 2).To_Int()
    Print(" mark string Int \b \{b}123{} \\{b} \{i, i}")
    Print(""" "raw" mark string \b
     Int \{b}123{} \ {}
      \{i}
    """)
    Print(""" 
       " raw "
        string
      """, """""")
    var c = false
    c = 1 <> 2
    c = 3 == 3
    c = 3 >= 1
    c = 1 <= 3
    c = not c
    c = true and false
    c = true or false
    var d = (2018.0309).To_Int()
    d = ~~ d && 1 || 2 ^^ 3 << 1 >> 2
    Print(b.To_Str(), d)
}

fun Test_string() do for var E in "love programming" do if E == 'e' do Print("love programming")

fun Test_optional() do {
    var a ?Int
    a = 1
    a?.To_Str()
    var B ?Str = ""
    B?.To_Str()
    var C ?Any = nil
    var D ?App = nil
    var E ?List[?Int] = List_of[?Int](0)
    E?.[0]?.To_Str()?.To_Str()
    var F = D ?: App$()
}

fun Test_reference() do {
    var x Int = 1
    var y ?Int = 2
    fun Swap(a !Int, b !?Int) do {
        b, a = a, b ?: 2
    }
    Swap(x!, y!)
}

fun Test_list() do {
    var Single = List_of(1)
    var numbers = List_of(1, 2, 5, 6, 8, 4)
    numbers.Append(3 + 7)
    numbers.Remove(6)
    var Three = 3
    numbers.[Three] = 5
    var take = numbers.[0]
    take = In_package_array$().Arr.[2]
    var Anys = List_of[Any]("123", 432, App$())
    var Numbers_in_numbers = List_of(List_of(1, 1, 1), List_of(1, 1, 1))
    Numbers_in_numbers.[0].[0] = 3
    var Empty = List[List[Int]]$()
    var Array Array[Int] = Array_of(1, 2, 3)
    for var i, v in numbers.WithIndex() do {
        Print(i, " :", v)
    }
    var Slice = numbers.Slice(0, nil)
    var Slice2 = numbers.Slice(nil, 3)
}

fun Test_dict() do {
    var Empty = Dict[Str, Dict[Int, Int]]$()
    var temp = Dict_of(Pair_of("k1", 1), Pair_of("k2", 2))
    temp.["k3"] = 3
    for var k, v in temp.WithIndex() do {
        Print(k)
        Print(v)
    }
    temp.Remove("k1")
    Print(temp.["k2"])
}

fun Test_combined_type() do {
    // swift [Int:[[Str:[Str:[Str]]]]]
    // go map[Int][]map[Str]map[Str][]Str
    // c# Dictionary<Int,List<Dictionary<Str,Dictionary<Str,List<Str>>>>>
    var Feel Dict[Int, List[Dict[Str, Dict[Str, List[Str]]]]]
}

fun Test_if() do {
    var X = 5
    if X == 2 do { 
        Print(2)
    } else if X == 3 do {
        Print(3)
    } else do { 
        Print("else")
    }
    if X == 5 do Print("yes")
}

fun Test_type_convert() do {
    var A Any = Dict[Str, Int]$()
    var B = A.(Dict[Str, Int])
    var X = App$()
    var Y = X.(Program)
    var Z1 = (12.34).To_F32()
    var Z2 = Z1.To_I64()
    Print( Z2.To[Any]().To[I64]() )
    Print( Y :: Program )
    Print( X.(Program).running )
    Print( typeof(Program) )
}

fun Test_switch() do {
    var X Any = 3
    if X in {
        case == 1, 2, 3 do
            Print("1,2,3") 
        case == nil do
            Print("null")
        case :: Str do
            Print("string")
        case :: Int i do
            Print("Int")
        else do
            Print("default")
    }
}

fun Test_foreach() do {
    Print("\n 0 up to 10 step 2: ")
    for var E in 0 to 10 by 2 do {
        Print(E, ", ", "")
    }
    Print("\n 0 up until 8: ")
    for var E in 0 until 8 do {
        Print(E, ", ", "")
    }
    Print("\n 8 down until 0: ")
    for var E in 8 downuntil 0 do {
        Print(E, ", ", "")
    }
    Print("\n 10 down to 0 step 2: ")
    for var E in 10 downto 0 by 2 do {
        Print(E, ", ", "")
        if E == 6 do continue
    }
    Print("\n 0 to 7 reversed: ")
    for var E in (0 until 8).Reversed() do {
        Print(E, ", ", "")
    }
    for var E in (0 until 8).Reversed().Reversed() do {
        Print(E, ", ", "")
    }
    Print(" ")
    var Arr = List[Int]$()
    for var E in Arr do {
        Print(E)
    }
    for var E in 7 until 7 do {
        Print(E)
        break
    }
}

fun Test_while() do {
    var a = 0
    var B = 8
    for a < B do {
        a += 1
    } else do {
        Print("loop no break")
    }
}

fun Test_check() do {
    var z1 ?Defer = nil
    ! (Z2 := Defer$(); Z2) {
        ! {
            z1 = Defer$()
            ! (Z3 := Defer$(); Z3) {
                var X = 1 * 1
                var Y = 1 + 1
            }
        } or :: IOException => ex {
            ! <- ex
        } or => e {
            ! <- e
        } and {
            if z1 <> nil do {
                z1.Dispose()
            }
        }
    }
}

fun Test_func(s Str = "func") (out1 Str, out2 Int) do {
    s = s + "test"
    var I1 = 1+1*3*9/8
    var I2 = I1 + 5 + (I1 + 8)
    fun Infunc() do ret
    Infunc()
    ret s, I2
}

fun Test_func_params(a Int, b Int, fn fun(Int, Int, Int, Int)(Str, Int, Int, Int),
    arr ...Int) (a Int, b Str, c Str) do {
    ret 0, "", ""
}

fun Test_lambda() do {
    fun Test1(fn fun(Int, Int)(Int, Int)) do {
        var i1, i2 = fn(1, 2)
    }
    Test1(fun(i1, i2) do { ret i1, i2 })

    fun Test2(fn fun()(Int)) do {
        var i1 = fn()
    }
    Test2(fun() do 1)

    fun Test3(fn fun(Int)) do {
        fn(1)
    }
    Test3( fun(it Int) do {
        Print(it)
    })
    Test3( fun(it) do {
        Print(it)
    })
    fun Test4(fn fun(Int)(Int)) do { 
        fn(18) 
    }
    Test4(fun(it)do it+1)
}

fun Test_define() do {
    var a = 1
    if a == 1 do {
        var b = 2
        b = 3
        a = 3
    } else if a == 2 do {
        var b = 2
        b = 3
        if b == 2 do {
            a = 1
        }
    } else do {
        var b = 2
        b = 3
        a = 3
    }
    if a in {
        case == 1 do
            var b = 2
            b = 3
            a = 3
            if a == 3 do {
                b = 1
                a = 1
            } else do {
                a = 2
            }
        case :: Int c do
            c = 2
            a = 1
        else do
            var b = 2
            b = 3
            a = 3
    }
    ! {
        a = 2
    } or => e {
        e = Exception$()
    }
}

fun Test_interface(i Protocol) do {}

var Const_data = 256
var Const_data2 Str = "512"
var Const_data3 Int = Const_data
fun Const_function() (v Int) do { 
    ret Const_data
}

fun 测试中文(甲 Int) (乙 Int) do {
    var 乙 = 甲 + 1
    ret 乙
}

In_package_array := $(Arr List[Int]) {}
In_package_array := (->$me) {
    me.Arr = List_of(1,2,3,4,5)
}

Defer := $(data Str = "") {
    IDisposable
    Dispose := () {}
}

App := $(
    i Int = 1,
    arr ?Array[Int] = nil,
    _Name Str = "name",
    _b Int = 3,
    `get, set`
    a Int = 5,
    `get, set`
    f Str = ""
) {
    Program
    Protocol

    Test_package := () {
        var Item = Program$()
        Item = new()
        var Item2 = List[Int]$()
        var Item3 = Dict[Str, Int]$()
        var Item4 = Package_child$(1,2)
    }

    Test_func_template := [t1, t2](data1 t1, data2 t2 -> data App) {
        ret this
    }

    C := (x Int -> y Int) {
        ret x + this._b
    }

    D := (-> x Int) {
        ret 3
    }

    E := (->) {
    }
}

Result := $(Data Str = "") {}

Test_package_template := [t class]$(data t) {
    Generic := (a t) {}
}

Test_protocol_template := [t class]$ {
    Test : [h class](i h->)
    Test : (i t->)
}

Test_implement_template := $() {
    Test_protocol_template[Test_implement_template]
    
    Test := [h class](i h) {}
    Test := (i Test_implement_template) {}
}

Program := $(`get, set`name Str = "", running Bool = false) {}

Protocol := $ {
    C : (x Int -> y Int)
    D : (->y Int)
    E : (->)
}

`"SQL ORM", Table("test")`
Test_annotation := $(
    `Key, Column("id")`
    id Str,
    `Column("nick_name")`
    nick_name Str,
    `Column("profile")`
    profile Str
) {}

Test_enum := $Ok or Err{}

Package := $(x Int = 1, y Int = 2) { me ->
    ParentFunc := () {
        me.x = 21
        Print("package")
    }
}
Package := (y Int->$me) {
    me.x = Const_data
    me.y = y
}

Package_child := (x Int, y Int->$)(y) {
    this.x = x
}
Package_child := $() { me, super ->
    Package

    .ParentFunc := () {
        x = 64
        Print("package child")
    }
}