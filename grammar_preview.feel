#: Grammar Overview

#: Export Name Space
<- demo

#: Import Name Space
-> {
    System
    System.Linq
    System.Text
    System.Threading.Tasks
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    _ := IO.File #: 可以隐藏元素使用内容
}

Main := (->) {
    #: Define, 一般情况下编译器会自动判断类型
    String := "10"   #: str
    Number := 1.2    #: num
    Integer := 123   #: int
    Boolean := true  #: bool
    SmallFloat := (1.2).to_f32() #: basic type convert

    #: Const
    PI := 3.141592653

    #: Mark String
    Format := "the value is ${Integer}, ${Number}, ${Boolean}"

    #: Array
    Array: array int = array int{1;2;3}

    #: List
    !List := list int{ 1;2;3;4;5 }
    List = { 1;2;3;4;5 }
    print( List[0] ) #: 使用下标获取

    #: Set
    Set := hashset int{ 1;2;3;4;5 }

    #: Dictionary, 前面为key，后面为value
    !Dictionary := {["1"]=false; ["2"]=true}
    Dictionary = dict str bool{ ["1"]=false; ["2"]=true}
    print( Dictionary["1"] ) #: 使用key获取

    Stack := stack int{}
    Queue := queue int{}

    #: Anonymous Template
    New := {
        title := "nnn"
        number := 8
    }

    #: Function
    Fn := (in: int -> out: int) {} #: (int->int)

    #: Function with no params no return
    do_something_void := (->) {
        do_something_a()
        do_something_b()
    }

    #: Full Function with in params and out params
    do_something_with_params := (x: int, y: str -> a: int, b: str) {
        <- x, y
    }

    B2C()
    #: 使用 _ 舍弃返回值
    _ = A2B(3, "test")

    #: Judge，当表达式的结果只有Bool时，相当于if，只当True时才执行
    1+1 >< 2 ? {
        do_something_a()
    } _ { #: else
        do_something_b()
    }

    a, b := 1, 2; a < b ? {
        do_something()
    }

    #: pattern match
    [x] 0..6, 7, 8, 9 ? {
        do_something_a()
    } 14 ? {
        do_something_b()
    } _ { #: default
        do_somethingC()
    }

    #: type match
    [object] _: str ? { 
        print("string") 
    } _: int ? { 
        print("integer") 
    } _: num ? { 
        print("float") 
    } _: bool ? { 
        print("boolean") 
    } _: any ? {
        print("object")
    } nil { 
        print("null") 
    }

    a := 2; [a] 1 ? {
        do_something()
    }

    #: Loop, use identify to take out single item, default is it  
    array @ item {
        print(item)
    }
    #: take index and value, both worked at Dictionary
    array @ [index]value {
        print(index, value)
    }

    #: Iterator, Increment from ..(step) to, Decrement from ...(step) to, (step) can omit
    0 .. 100 @ it {
        print(it)
    }
    10 ... 1 @ it {}

    #: Infinite
    true @ {
        a > b ? {
            ~@  #: jump out loop
        } _ {
            @   #: continue
        }
    }
    #: Conditional
    !a := 0
    a < 10 @ {
        a += 1
    } _ {
        #: Loop else
    }

    !a := 0; a < 10 @ {
        a += 1
    }
    
    #: Check, listen the Exception Function
    Fi := File("./test.feel")
    F := Read_File("demo.feel"); F ! {
        do_some_thing()
    }
    ! {
        do_some_thing()
    } ex {
        ! <- ex #: Use ! <- to throw an Exception
    } _ {
        Fi.Dispose()
    }

    #: Template
    View := $ {
        !width: int
        !height: int
        !background: str
    }

    #: 可以通过 me 来访问包自身属性或方法，当作为指针类型使用时 me 是指针，否则是值类型。
    Button := $ me {
        !width: int
        !height: int
        !background: str
        !title: str
        click := (->) {
            print( me.title )
            doSomeThingA()
            doSomeThingB()
        }
    }

    Image := $ me {
        #: 私有属性，不能被外部访问
        !_width := 0
        !_height := 0
        !_source := "" 

        init := (w: int, h: int, s: str->v: Image) {
            me._width, me._height, me._source = w, h, s
            <- me
        }
    }

    #: Interface
    Animation := $ {
        !speed: int
        move: (s: int ->)
    }

    #: Combine Template
    ImageButton := $ me {
        Image
        Button
        !title: str
        #: Implement interface
        !speed := 0
        move := (s: int ->) {
            t = 5000/s
            play( s + t )
        }

        init := (w: int, h: int->v: ImageButton) {
            me.Image.init(w, h, "img")
            me.title = "img btn"
            <- me
        }
    }

    #: Create an Template object
    IB := ImageButton{}
    #: Calling property
    IB.title = "OK"
    #: Calling method
    IB.button.show()
    #: Calling protocol
    IB.move(6)

    #: Create an object with simple assign
    IB2 := ImageButton{
        title = "Cancel"
        background = "red"
    }

    #: Create an object with params
    Img := Image{}.init(30, 20, "./icon.png")
    ImgBtn := ImageButton{}.init(1, 1)

    #: judge type
    IB?: ImageButton ? {
        #: convert type
        (IB!: View).show()
    }

    #: get type
    print( typeof(ImageButton) )

    #: yield
    yield_function := (-> @ r: int) {
        #: yield return
        @ <- 123
        #: yield break
        @ <-
    }

    task := (in: int -> out: int) {
        #: make a function to async
        ~> do_some_thing_A()
        #: make a function to await
        do_some_thing_B~>()
        #: make channel
        ch := chan int(1)
        #: await
        ch <~ in
        #: await
        <- <~ ch
    }

    x := task(6)

    #: Annotation
    #assemby -> Table("user") #D(false, Name="d", Hide=true)
    User := $ {
        #Column("id") #Required #Key
        !id: str
        #Column("nick_name") #Required
        !nick_name: str
        #Column("time_update") #Required
        !time_update: int
    }

    #: Optional Type
    A: int? = nil
    #: Safe Call
    E := A?.to_str()
    #: OrElseValue
    F := A ?? 128

    #: Reference
    swap := (!x: int!, !y: int!->) {
        x?, y? = y?, x?
    }
    !a, !b := 1, 2
    swap(a!, b!)
    
    #: Generic Template
    table := T $ {
        !data: T
        set_data := (d: T ->) {
            data = d
        }
    }
    #: Generic function
    Add := T (x1: T, x2: T -> y: T) {
        <- x1 + x2
    }

    #: Lambda Function
    arr.select( {it -> it > 2} )
    arr.select{it -> it > 2}

    #: Func params
    Func := (in: (int -> int) ->) {
        in(1)
    }
    Func( (x: int -> y: int) {
        <- (y)
    })

    #: linq
    arr = expr @ id -> where expr -> order expr -> select expr

    #: control
    Data := $ {
        #get #set
        !c: int
        !d: int
        #add #remove
        !e: PropertyChangedEventHandler
    }

    Color := [?] {
        Red
        Green
        Blue
    }

    #: operator override
    complex := $ {
        !v: int
        !i: int

        # "add"
        + := (x: complex->y: complex) {
            <- complex{ v = v + x.v; i = i + x.i }
        }

        # "index get"
        [x: bool->] := (->y: int) {
            x ? {
                <- v
            } _ {
                <- i
            }
        }
        # "index set"
        [x: bool->] := (y: int->) {
            x ? {
                v = y
            } _ {
                i = y
            }
        }
    }
}
