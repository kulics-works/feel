# 协议
我们在现实中常常用协议来规定一些特定的规则，让人或事物可以按照预期的规则来做事情。
我们在程序语言里也常常需要这么做，这个功能就是协议。

协议规定用来实现某一特定功能所必需的方法和属性，让包来遵守。

我们的包可以像签署协议一样引入我们需要的协议，然后声明协议要求的所有属性，这样我们就认为这个包签署了协议。
## 定义
我们只需要使用 `id -> {}` 语句就可以定义一个协议。

例如：
```
Protocol ->
{
}
```
这就是一个空的协议。

接下来，让我们设计一个学生都需要完成的艰巨任务……作业。

例如：
```
HomeWork ->
{
    Count :i32
    Do ()->(){}
}
```
这是一个作业协议，它有两个属性，一个是需要做作业的数量，一个是完成作业的函数。

定义的方式和包内定义属性的方式如出一辙。

与包不同的是，协议定义时属性不需要具体的数值或函数内容，只需要确定类型。

接下来，我们就要让学生来实现这个协议了。
## 实现协议
和扩展函数类似，我们可以在需要的包中，使用 `id += protocol {}` 语句，就可以实现这个协议。

例如：
```
Student += HomeWork
{
    Count :i32

    Do ()->()
    {
        SpendTime.(1)           // 花费了一个小时
        ..HomeWork.Count -= 1   // 完成了一个
    }
}
```
我们的学生写作业真是非常艰苦的……

让我们来解释一下这段包含协议发生了什么：
1. 我们定义了一个协议属性，这个属性的标识符就是协议的名称 `HomeWork`， 所以我们可以像定义了一个属性一样去使用它。
1. 在协议内我们包含了协议规定的两个属性 `Count, Do` ，根据规定，一个也不能少。
1. 我们给协议的两个属性都分别编写了真实的值和函数，这样这两个属性就成为了 `Student` 的有效子属性之一。
1. 我们在 `Do` 里面做了一些事情，并且通过调用 `HomeWork` 的属性减少了作业的总量。

需要注意的是，协议属性也是属性，我们在一个包内不能实现两个同名的协议，也不能有其它属性或方法与协议同名，但是不同名的协议所包含的方法允许同名。

## 使用协议
包含了协议之后，我们就能使用拥有协议的学生包了。

例如：
```
Peter := Student.{ ...Count=999999 }
Console.WriteLine.( Peter.HomeWork.Count )
// 打印 999999，好多呀
Peter.HomeWork.Do.()
// 做了一次作业
Console.WriteLine.( Peter.HomeWork.Count )
// 打印 999998，还是好多呀
```
如果只是这样使用，那和在包里直接定义这两个属性比就没什么优势了。

让我们来回想一下协议的作用，协议是让每个包含了协议的包都拥有了规定的相同的属性和方法。

这样对于协议的制定者来说，就无需关心包是如何遵循协议的，只需要知道它们都遵循了，就能用同样的方法去使用它们。

现在我们可以创建各种各样的学生，它们都遵循了一样的协议，我们可以无差别使用协议里的功能。

例如:
```
// 创建了三个不同类型的学生包
StudentA := ChineseStudent.{}
StudentB := AmericaStudent.{}
StudentC := JapanStudent.{}
// 让他们分别做作业
StudentA.HomeWork.Do.()
StudentB.HomeWork.Do.()
StudentC.HomeWork.Do.()
```
更有效率的做法是把这个功能写进函数，让函数来帮我们重复调用协议的功能。

例如：
```
DoHomeWork (student: HomeWork)->()
{
    student.Do.()
}
// 现在我们就可以更简单地让每个学生做作业了
DoHomeWork.(StudentA.HomeWork)
DoHomeWork.(StudentB.HomeWork)
DoHomeWork.(StudentC.HomeWork)
```
当然，更好的做法是把这些学生都放进数组，这样我们就可以使用循环来处理这些重复的工作了。

例如：
```
Arr := []HomeWork.{}
Arr.Add.( StudentA.HomeWork )
... // 塞进很多很多学生
Arr.@ 
{
    DoHomeWork.(it)
}
```
╮（￣▽￣）╭  
完美

## 类型判断
因为包类型可以被转为协议类型使用，所以在使用过程中就不能确定数据的原始类型。

但有时候我们又需要获得数据的原始类型来处理，我们可以使用类型判断来帮助我们完成这个事情。

我们可以使用`value.?:type`来判断数据的类型，使用`value.!:type`来将数据转化为我们的类型。

例如：
```
func (hw:HomeWork)->()
{
    // 判断是否中国学生
    ? hw.?:ChineseStudent 
    {
        // 转换为中国学生数据
        cs := hw.!:ChineseStudent
    }
}
```
需要注意的是，如果不能正确地转换类型，会得到一个`null`结果。

### 

## 本章示例
```
Demo
{
    .. System

    Main ()
    {
        S := B.{}
        B.A.Do.()
        C.( B.A )
    }

    A ->
    {
        X : i32
        Do ()->() {}
    }

    B {}->
    {
        Y := 5
    }

    B += A
    {
        X := 0
        Do ()->() 
        {
            ..A.X += 1
        }
    }

    C (a:A)->()
    {
        a.Do.()
        ? a.?:B 
        {
            Console.WriteLine.( a.!:B.Y )
        }
    }
}
```


[下一章](枚举类型.md)