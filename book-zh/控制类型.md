# 控制类型
控制类型是对数据操作封装的代码块。

通常我们会将一些数据控制处理封装成为控制类型，这样在使用数据时就无需执行额外的方法。

## 简单定义
如果我们暂时不需要定义具体的控制方法，我们只需要使用`id:type`来定义一个控制类型。

例如：
```
number :i32
```
这样便定义了一个没有额外方法的控制数据，它内置了默认的控制方法。

## 获取操作
如果我们想设定一个获取的操作，我们可以在后面加入`^`和额外代码块定义。

例如：
```
number :i32
^get    // 表示获取，相当于其它语言中的getter
{  
    <- (7)     // 只返回 7
}
```
这样number就具有了一个特殊的获取值方法，在调用number时会执行内部的逻辑。

需要注意的是，这个控制数据只有一个获取方法，那么它就只支持获取操作，调用者无法给它赋值。
## 设置操作
有了以上的例子，我们很自然能够想到设置操作改如何处理。

例如：
```
number :i32
...
^set    // 表示设置，相当于其它语言中的setter
{
    // ？？？该把值给谁？？？
}
```
是的，这里引出了一个问题，控制类型是用来控制操作的，实现操作的时候无法使用自身来存储数据。  
因此我们需要使用另一个搭配的数据来使用控制类型。

例如：
```
_number := 0

number :i32
^set 
{
    _number = value     // value代表输入的值
}
```

需要注意的是，这个变量只有一个设置方法，那么它就只支持设置操作，调用者无法获取它的值。

一个完整的读写例子如下：
```
_number := 0
number: i32
^get
{
    <- (_number)
}
^set
{
    _number = value // value代表输入的值
}
```

只有当我们需要实现操作细节的时候才需要如此处理控制数据。

在大部分时候，我们可以只使用简单定义来完成任务，因为没有特殊的操作，所以它内置了自己的值无需我们额外处理。

### [下一章](包类型.md)

## 本章示例
```
Demo
{
    .. System

    Main ()
    {
        Console.WriteLine.(a)
        c = 5
        Console.WriteLine.(b)
        Console.WriteLine.(c)
    }

    a : i32
    ^get { <- (3) }
    
    b := 0
    c : i32
    ^get { <- (b) }
    ^set { b = value }
}
```


