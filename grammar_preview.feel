// Grammar Overview

// Export Name Space
mod demo

// Import Name Space
use {
    System
    System.Text
    System.Threading.Tasks
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    . = IO.File // 可以隐藏元素使用内容
}

fun Main() {
    // Define, 一般情况下编译器会自动判断类型
    var string Str = "10"
    var number Num = 1.2
    var integer Int = 123
    var boolean Bool = true
    var smallFloat = (1.2).To_F32() // basic obj convert

    // Const
    var PI = 3.141592653

    // Mark String
    var format = "the value is \{integer}, \{number}, \{boolean}"

    // Array
    var array Array[Int] = Array_of(1, 2, 3)

    // List
    var list List[Int] = List_of(1, 2, 3, 4, 5)
    Print( list.(0) ) // 使用下标获取

    // Dictionary, 前面为key，后面为value
    var dict Dict[Str, Bool] = Dict_of(new("1", false), new("2", true))
    Print( dict.("1") ) // 使用key获取

    // Anonymous Template
    var v1 = typ(title Str, number Int)("nnn", 8)
    var v2 = typ(title, number)("nnn", 8) // obj infer

    // Function
    fun f(a Int) Int {
        ret a
    }

    // Function with no params no return
    fun do_something_void() {
        do_something_a()
        do_something_b()
    }

    // Full Function with in params and out params
    fun do_something_with_params(x Int, y Str) (x Int, y Str) {
        ret new(x, y)
    }

    // Function can omit return obj
    var f fun(Int,Int) Int = fun x Int, y Int { x + y }
    fun f(x Int, y Int) { x + y }

    // Currying
    var add = fun x { fun y { x + y } } 

    do_something_void()
    // 使用 _ 舍弃返回值
    _ = do_something_with_params(3, "test")

    // Judge，当表达式的结果只有Bool时，相当于if，只当True时才执行
    var v = if a { b } else { c }
    if a {
        b
    } else {
        c
    }

    if a {
        b
    } else if c {
        d
    } else {
        e
    }

    if var a, b = 1, 2; a < b {
        d
    } else if var c = 3; a == c {
        d
    }

    // Judge obj
    if ib case it Image_Button {
        it.show()
    }

    // Complex Judge
    if x case in 0 to 6 or 7 or 8 or 9 {
        do_something_a()
    } case 14 {
        do_something_b()
    } case < 18 {
        do_something_c()
    } case > 18 and < 32 {
        do_something_d()
    } case it Int {
        do_something_e()
    } else {
        do_something()
    }

    // Loop, use identify to take out single item
    for array case item {
        Print(item)
    }
    // take index and value, both worked at Dictionary
    for array.WithIndex() case index, value {
        Print(index, value)
    }

    // Range
    for 0 to 100 case it {
        Print(it)
    }
    for 0 until 100 case it {
        Print(it)
    }
    for 10 downto 1 by 2 case it {
        Print(it)
    }
    
    // Conditional
    var a = 0
    for a < 10 {
        a += 1
    }
    for var i = 0; i < 10 {
        i += 1
    }
    // Infinite
    for {
        if a > b {
            break // jump out loop
        }
        continue // continue
    }
    
    // Check, listen the Exception Function
    var fi = open_file("./test.feel")
    try var f = read_file("demo.feel"); f {
        do_some_thing()
    }
    try {
        do_some_thing()
    } case ex Exception {
        throw ex // Use ! <- to throw an Exception
    } else {
        fi.dispose()
    }

    // Template
    typ View(width Int, height Int, background Str)

    // 可以通过 this 来访问包自身属性或方法，当作为指针类型使用时 this 是指针，否则是值类型。 this 可以自定义。
    typ Button(width Int, height Int, background Str, title Str) {
        fun Click() {
            Print( this.title )
            doSomeThingA()
            doSomeThingB()
        }
    }
    // 私有属性，不能被外部访问
    typ Image(_width Int, _height Int, _source Str) {
        fun Init(w Int, h Int, s Str) Image {
            this._width, this._height, this._source = w, h, s
            ret this
        }
    }

    // Interface
    typ Animation {
        fun Move(s Int)
        fun Stop()
    }

    // Combine Template
    typ Image_Button(as Image, as Button, title Str) {
        // Implement Interface
        fun Move(s Int) {
            t = 5000/s
            play( s + t )
        }
        fun Stop() {}

        fun Init(w Int, h Int) Image_Button {
            this.Image.Init(w, h, "img")
            this.title = "img btn"
            ret this
        }
    }

    // Create an Template object
    var ib = Image_Button(1, 2)
    ib = new(2, 1)
    // Calling property
    ib.title = "OK"
    // Calling method
    ib.Show()
    // Calling protocol
    ib.Move(6)

    // Use Interface
    fun play_animation(a Animation) {
        a.Move(1000)
        a.Stop()
    }
    play_animation(ib)

    // Create an object with simple assign
    var ib2 = Image_Button(
        title = "Cancel",
        background = "red"
    )

    // Create an object with params
    var img = Image(30, 20, "./icon.png")
    var imgbtn = Image_Button().Init(1, 1)

    fun task(i Int) (r Int) {
        // make a function to async
        go do_some_thing_A()
        // make channel
        var ch = Chan[Int](1)
        // await
        ch <~ i
        // await
        ret <~ ch
    }

    var x = task(6)

    // Annotation
    `table("user"), property(false, name = "d", hide = true)`
    typ User(
        `column("id"), required, key`
        id Str,
        `column("nick_name"), required)`
        nick_name Str,
        `column("time_update"), required)`
        time_update Int
    )

    // Optional obj
    var a Opt[Int] = nil
    // Safe Call
    var e = a?.To_Str()
    // OrElseValue
    var f = a ?: 128

    // Reference
    fun swap(x ref Int, y ref Int) {
        x, y = y, x
    }
    var a, b = 1, 2
    swap(ref a, ref b)
    
    // Generic Template
    typ Table[T Any](data T) {
        fun Set_data(d T) {
            data = d
        }
    }
    Table[Int](1)
    // Generic function
    fun Add[T Any](x1 T, x2 T) (r T) {
        ret x1 + x2
    }
    Add[Int](1, 2)

    // Lambda Function
    arr.select(fun it { it > 2 })

    // Func params
    fun f(i fun(Int)Int) {
        i(1)
    }
    f(fun x Int {
        ret y
    })

    typ Color case Red, Green, Blue
    typ Unit()
    typ Person(age Int, name Str)
    typ Man(as p Person)
    typ Option[T] {
        case None
        case T
    }
    typ Result[T] {
        case Error
        case T
    }
    typ Error {
        fun error() Str
    }
    fun Function(age Int, name Str) {}
    typ Option[T] {
        case None
        case T
    }
    impl Option[T] {
        fun orElse(v T) T {
            if this case i T {
                ret i
            } else {
                ret v
            }
        }
    }

    var op ?Int = nil
    op = 1
    if op case v Int {
        Print(v)
    }
    if var v = op as Int {
        Print(v)
    }
    
    // operator override
    typ Complex(v Int, i Int)
    impl Complex {
        // Complex + Complex
        fun Plus(x Complex) (r Complex) {
            ret Complex(v + x.v, i + x.i)
        }
        // y = Complex.(x)
        fun Get(x Bool) (r Int) {
            ret if x { v } else { i }
        }
        // Complex.(x) = y
        fun Set(x Bool, y Int) {
            if x {
                v = y
            } else {
                i = y
            }
        }
    }
}

typ Option[T Any] {
    case Null
    case Some[T]
}

typ Some[T Any](as value T)

typ Iterator[Item Any] {
    fun next() Option[Item]
}

typ Iterable[Item Any] {
    fun iter() Iterator[Item]
}

typ Collection[Item Any] {
    as Iterable[Item]
    fun size() Int
    fun isEmpty() Bool
}

typ List[Item Any] {
    as Collection[Item]
    fun append(item Item)
    fun get(index Int) Item
    fun set(index Int, item Item)
}

typ EquatableList[Item Any] {
    as List[Item]
    fun equals(other This) Bool
}

fun arrayListOf[Item Any](items ...Item) ArrayList[Item] {
    var data = newArrayListWithCap[Item](items.size())
    for items case v {
        data.append(v)
    }
    ret data
}

typ ArrayList[Item Any](array Array[Option[Item]], len Int)

fun newArrayList[Item Any]() ArrayList[Item] {
    ret ArrayList[Item](Array[Option[Item]](10, nil), 0)
}

fun newArrayListWithCap[Item Any](cap Int) ArrayList[Item] {
    ret ArrayList[Item](Array[Option[Item]](cap, nil), 0)
}

impl (this)ArrayList[Item Any] {
    fun iter() Iterator[Item] {
        ret ArrayListIterator(this, 0)
    }

    fun size() Int {
        ret this.len
    }

    fun isEmpty() Bool {
        ret this.len == 0
    }

    fun append(item Item) {
        if this.len < this.array.size() {
            this.array.(this.len) = item
        } else {
            var newArray = Array[Option[Item]](this.array.size() * 1.5, nil)
            for this.array.WithIndex() case (i, v) {
                newArray.(i) = v
            }
            this.array = newArray
        }
        this.len += 1
    }

    fun get(index Int) Item {
        if index > 0 | index < this.len {
            if this.array.(index) case v Some[Item] {
                ret v.value
            }
        }
        throw OutOfRange()
    }

    fun set(index Int, item Item) {
        if index > 0 | index < this.len {
            this.array.(index) = Some(item)
        }
    }
}

typ Equatable {
    fun equals(This) Bool
}

impl (this)ArrayList[Item Equatable] {
    fun equal(other ArrayList[Item]) Bool {
        if this.len <> other.len {
            ret false
        }
        for this.array.WithIndex() case (i, v) {
            if not v.equals(other.array.(i)) {
                ret false
            }
        }
        ret true
    }
}

typ ArrayListIterator[Item Any](
    data ArrayList[Option[Item]],
    index Int
)

impl (this)ArrayListIterator[Item Any] {
    fun next() Option[Item] {
        if this.index < this.data.size() {
            this.index += 1
            ret this.data.(this.index) 
        }
        ret nil
    }
}
