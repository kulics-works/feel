# 判断
判断语句通过设定的一个或多个条件来执行程序，在条件为 `true` 时执行指定的语句，在条件为 `false` 时执行另外指定的语句。

我们只需要使用 `? value {}` 就可以声明判断语句，根据后面的值进入对应的区域。

例如：
```
? true
{
    Console.WriteLine.("true")  // true
}
```
## 布尔判断
当判断值只会为布尔类型时，语句只有当为 `true` 时才执行。如果我们同时需要处理 `false` 的情况，可以在之后使用 `? value {}` 来声明另一个处理语句。

例如：
```
b := false
? b
{
    ... // 因为 b 为 false，所以永不会进入这个分支 
}
?
{
    ... // 处理 false
}
```


相对于其它语言来说，下面的例子可以认为是 `if elseif else` 结构。

例如：
```
i := 3
? i == 0
{
    ...
}
? i == 1
{
    ...
}
? i == 2
{
    ...
}
? 
{
    ...
}
```


## 条件判断

如果我们需要对一个标志符进行判断，可以使用`id.?{}`语句，语句实现多条件匹配，搭配匹配条件来执行相应的逻辑，这样它就只会执行匹配成功的语句。

例如：
```
i.? 1
{
    ...
}
2
{
    ...
}
```
这种条件判断非常适合对某一个标识符的多条件判断，避免编写过多的判断条件。

是的，就像上面布尔判断一样，这里的每一个条件被执行完成后都会被结束，并不会继续向下执行。

### 缺省条件
如果需要一个缺省条件来执行逻辑怎么做？我们可以使用一个匿名标识符`_`来完成这个目标。

例如：
```
i.? 1
{
    ...
}
2
{
    ...
}
_
{
    ...
}
```
这样匹配不到的情况下，就会到缺省处理区域去执行。

相对于其它语言来说，这可以认为是 `switch case default` 结构。

### 模式匹配
条件判断还能做的更多，比如我们需要判断标志符的类型，
可以使用`value.?id:type{}`语法来匹配类型，`id`可以省略，默认为`it`。

例如：
```
x.?
:i32 // 是否i32
{
    Console.Write.(it)
} 
content:str // 是否str
{
    Console.Write.(content)
} 
null // 是否为null
{
    Console.Write.("null")
}
```
### 获取类型
如果我们需要明确获取类型值，可以使用`?.(id)`或`?.(:type)`语法来获取。

例如：
```
?.(expr)    // 获取表达式类型值
?.(:type)   // 通过类型直接获取类型值
```
### 

## 本章示例
```
Demo
{
    .. System

    Main ()
    {
        a := 5
        ? a == 2
        { Console.WriteLine.(2) }
        ? a == 4
        { Console.WriteLine.(4) }
        ?
        { Console.WriteLine.("not find") }

        b := 7
        b.?
        5
        { Console.WriteLine.(5) }
        7
        { Console.WriteLine.(7) }
        _
        { Console.WriteLine.("not find") }

        Console.WriteLine.( ?.(b) )
        Console.WriteLine.( ?.(:i32) )
    }
}
```


[下一章](循环.md)