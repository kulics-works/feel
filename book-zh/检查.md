# 检查
程序可能会出现各种各样的异常。

- 可能是文件或者用户输入的内容导致的。
- 可能是编码错误或语言中缺少的功能。
- 当然，也可能是由于许多其他不可预知的因素。

异常无法完全避免，但是我们可以选择一些手段帮助我们检查和报告异常。

## 报告异常
我们可以在函数中的任何地方，使用`!.()`来声明一个异常数据。

例如：
```
ReadFile (name:str)->()
{
    ? name.Length == 0
    {
        !.( Exception.{"something wrong"} )
    }
}
```
这样我们就声明了一个异常，异常说明是`something wrong`，一旦外部调用者使用了不合法长度的`name`，这个异常就会向上报告，直到被处理或者被忽略。
## 检查异常
我们可以在调用函数的时候，使用`! {} id {}`语句来检查可能会有异常的区块。

例如：
```
!
{
    ReadFile.("temp.txt")
}
err
{
    Console.WriteLine.(err.message)
}
```
在这里，`!`区块表示所有受到检查的功能逻辑，`err`表示将错误数据定义为标识符`err`，其作用就像入参。

一旦读取文件函数出现了异常，就会检查出`err`并执行打印功能，如果没有，则一切正常，不会进入异常处理部分的功能。

同样的，检查逻辑也在函数内，所以如果有处理不了的异常，可以继续向上报告。

例如：
```
...
err 
{ 
    !.(err)
}
```
那么我们怎么区分不同类型的异常呢？

很简单，我们在标识符后面指定类型即可。

例如:
```
e : IOException
{
    ...
}
```

## 检查延迟
如果我们有一段功能希望无论程序正常或异常都能处理，例如关键资源的释放问题，我们可以使用检查延迟特性。

很简单，使用`~! {}`就能声明一段检查延迟的语句。

例如：
```
func ()->()
{
    file := ReadFile.("./somecode.xy")
    ~!
    {
        file.Release.()
    }
    ...
}
```
这样我们就声明了`file.Release.()`这条释放文件的语句，这条语句不会被立刻执行，而是会等待函数退出前调用。

有了检查延迟，我们就可以无需关心函数如何退出，安全地处理某些任务。

需要注意的是，正因为检查延迟是函数退出前执行的，并且无论程序运行状态异常与否都会执行，所以检查延迟中不能使用返回语句。

例如：
```
...
~!
{
    file.Release.()
    <- ()   // 错误，不能使用返回语句
}
```

### 检查延迟顺序
特别的，如果在一个语句块中使用了多个`~!`，最终执行是按照倒序逐个执行`~!`中的语句。这是因为`~!`都是放在最后执行的，所以先声明的就会最后执行，因此多个`~!`就会按照声明的倒序来执行。

例如：
```
~! { Console.WriteLine.("1") }
~! { Console.WriteLine.("2") }
~! { Console.WriteLine.("3") }

// 最终显示 3 2 1
```

### 检查延迟作用域
检查延迟的有效作用域仅仅是当前最靠近自己的一层语句块，这对于我们控制执行区域非常有帮助。

例如：
```
func ()->()
{
    ...
    [0~5].@
    {
        // 不会影响到循环外的逻辑
        ~! { Console.WriteLine.(it + 1) }
        Console.WriteLine.(it)
    }
    ...
}
```
### 自动释放
对于实现了自动释放协议的包，我们可以使用`!=`语法来定义变量，这样在函数执行完毕时就会自动释放。

例如：
```
res != FileResource.{"/test.xy"}
...
```

### [下一章](异步处理.md)

## 本章示例
```
Demo
{
    .. System

    Main ()
    {
        ! 
        {
            x := 1 * 1
        }
        err : IOException 
        {
            !.(err)
        }

        x != Defer.{}
        ~!
        {
            x.str = "defer"
            Console.WriteLine.(x.content)
        }
    }

    Defer {} ->
    {
        content :str
    }

    Defer += IDisposable
    {
        Dispose ()->()
        {
            ..content = null
        }
    }
}
```


