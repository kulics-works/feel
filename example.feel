mod example

use {
    System
    System.IO
    System.Collections.Generic
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    System.Threading.Tasks

    example.example_static => .
}

/*
   // main function
*/
fun Main() {
    do Print "main function"
    // run test
    Test_type()
    Test_operator()
    Test_string()
    Test_optional()
    Test_list()
    Test_dict()
    Test_switch()
    Test_if()
    Test_foreach()
    Test_while()
    var X = Test_func("testcall")
    Test_func_params(a = 1, b = 2,
    fun a, b, c, d {
        ret "", a, b, c
    })
    Test_check()
    Test_type_convert()
    Test_lambda()

    var Y = do Test_tuple 1 To_Str ()
    var P = example.App new ()

    P C 1
    do Test_interface P

    P Test_func_template[Int, Str] (1, "2") Test_package ()
    
    for true {
        break
    }
    
    if 1 == 1 {
        Print("test exception expression")
    }
    
    Read()
}

`get, set`
var static_x = 0

`get, set`
var static_y = "hello"

var static_g Int = 3

fun Test_tuple(i Int) (v Str) {
    ret "tuple"
}

fun Test_type() {
    var I1 I8 = 1              // sbyte
    var I2 I16 = 1             // short
    var I3 I32 = 1             // Int
    var I4 I64 = 1             // long
    var U1 U8 = 1              // byte
    var U2 U16 = 1             // ushort
    var U3 U32 = 1             // uint
    var U4 U64 = 1             // ulong
    var F1 F32 = 1             // float
    var F2 F64 = 1             // double
    var Char1 Chr = 'a'        // char
    var String1 Str = "123"    // string
    var Bool1 Bool = false     // bool
    var Int1 Int = 1           // Int
    var Num1 Num = 1.0         // double
    var Byte1 Byte = 1         // byte
    var Any1 Any = 1           // object
}

fun Test_operator() {
    var i Str = "128.687"
    i += ".890"
    var A = 003.141592653e3
    var b Int
    b = 2020_01_16
    b = 0b1010_1101
    b = 0X56_fa_C4
    b += Const_data
    b = + - b
    b = b + 1
    b = b * 2
    b = b / 2
    b = b % 2
    b = b ^ 2 To_Int ()
    Print(" mark string Int \b \{b}123{} \\{b} \{i, i}")
    Print(""" "raw" mark string \b
     Int \{b}123{} \ {}
      \{i}
    """)
    Print(""" 
       " raw "
        string
      """, """""")
    var c = false
    c = 1 <> 2
    c = 3 == 3
    c = 3 >= 1
    c = 1 <= 3
    c = not c
    c = true and false
    c = true or false
    var d = 2018.0309 To_Int ()
    d = ~~ d && 1 || 2 ^^ 3 << 1 >> 2
    Print(b To_Str (), d)
}

fun Test_string() {
    for E in "love programming" {
        if E == 'e' {
            Print("love programming")
        }
    }
}

fun Test_optional() {
    var a ?Int
    a = 1
    a?.To_Str()
    var B ?Str = ""
    B?.To_Str()
    var C ?Any = nil
    var D ?App = nil
    var E ?List[?Int] = List_of[?Int](0)
    E?.[0]?.To_Str()?.To_Str()
    var F = D ?: App new ()
}

fun Test_reference() {
    var x Int = 1
    var y ?Int = 2
    fun Swap(a !Int, b !?Int) {
        b, a = a, b ?: 2
    }
    Swap(x!, y!)
}

fun Test_list() {
    var Single = List_of(1)
    var numbers = List_of(1, 2, 5, 6, 8, 4)
    numbers.Append(3 + 7)
    numbers.Remove(6)
    var Three = 3
    numbers.[Three] = 5
    var take = numbers.[0]
    take = (In_package_array new ()).Arr.[2]
    var Anys = List_of[Any]("123", 432, App new ())
    var Numbers_in_numbers = List_of(List_of(1, 1, 1), List_of(1, 1, 1))
    Numbers_in_numbers.[0].[0] = 3
    var Empty = List[List[Int]] new ()
    var Array Array[Int] = Array_of(1, 2, 3)
    for i, v in numbers WithIndex () {
        Print(i, " :", v)
    }
    var Slice = numbers Slice (0, nil)
    var Slice2 = numbers Slice (nil, 3)
}

fun Test_dict() {
    var Empty = Dict[Str, Dict[Int, Int]] new ()
    var temp = Dict_of(Pair_of("k1", 1), Pair_of("k2", 2))
    temp.["k3"] = 3
    for k, v in temp WithIndex () {
        do Print k
        do Print v
    }
    temp Remove "k1"
    do Print temp.["k2"]
}

fun Test_combined_type() {
    // swift [Int:[[Str:[Str:[Str]]]]]
    // go map[Int][]map[Str]map[Str][]Str
    // c# Dictionary<Int,List<Dictionary<Str,Dictionary<Str,List<Str>>>>>
    var Feel Dict[Int, List[Dict[Str, Dict[Str, List[Str]]]]]
}

fun Test_if() {
    var X = 5
    if X == 2 { 
        Print(2)
    } else if X == 3 {
        Print(3)
    } else { 
        Print("else")
    }
    if X == 5 {
        Print("yes")
    }
}

fun Test_type_convert() {
    var A Any = Dict[Str, Int] new ()
    var B = A as Dict[Str, Int]
    var X = App new ()
    var Y = X as Program
    var Z1 = 12.34 To_F32 ()
    var Z2 = Z1 To_I64 ()
    Print( Z2 To[Any] () To[I64] () )
    Print( Y is Program )
    Print( (X as Program).running )
    Print( typeof(Program) )
}

fun Test_switch() {
    var X Any = 3
    if X case == 1, 2, 3 {
        Print("1,2,3")
    } case == nil {
        Print("null")  
    } case is Str {
        Print("string")
    } case is Int i {
        Print("Int")
    } else {
        Print("default")
    }
}

fun ten() (v Int) {
    ret 10
}

fun Test_foreach() {
    Print("\n 0 up to 10 step 2: ")
    for E in 0 to do ten () by 2 {
        Print(E, ", ", "")
    }
    Print("\n 0 up until 8: ")
    for E in 0 until 8 {
        Print(E, ", ", "")
    }
    Print("\n 8 down until 0: ")
    for E in 8 downuntil 0 {
        Print(E, ", ", "")
    }
    Print("\n 10 down to 0 step 2: ")
    for E in 10 downto 0 by 2 {
        Print(E, ", ", "")
        if E == 6 {
            continue
        }
    }
    Print("\n 0 to 7 reversed: ")
    for E in 0 until 8 Reversed () {
        Print(E, ", ", "")
    }
    for E in 0 until 8 Reversed () Reversed () {
        Print(E, ", ", "")
    }
    Print(" ")
    var Arr = List[Int] new ()
    for E in Arr {
        Print(E)
    }
    for E in 7 until 7 {
        Print(E)
        break
    }
}

fun Test_while() {
    var a = 0
    var B = 8
    for a < B {
        a += 1
    } else {
        Print("loop no break")
    }
}

fun Test_check() {
    var z1 ?Defer = nil
    ! (Z2 := Defer new (); Z2) {
        ! {
            z1 = Defer new ()
            ! (Z3 := Defer new (); Z3) {
                var X = 1 * 1
                var Y = 1 + 1
            }
        } or :: IOException => ex {
            ! <- ex
        } or => e {
            ! <- e
        } and {
            if z1 <> nil {
                z1.Dispose()
            }
        }
    }
}

fun Test_func(s Str = "func") (out1 Str, out2 Int) {
    s = s + "test"
    var I1 = 1+1*3*9/8
    var I2 = I1 + 5 + (I1 + 8)
    fun Infunc() {
        ret
    }
    Infunc()
    ret s, I2
}

fun Test_func_params(a Int, b Int, fn fun(Int, Int, Int, Int)(Str, Int, Int, Int),
    arr ...Int) (a Int, b Str, c Str) {
    ret 0, "", ""
}

fun Test_lambda() {
    fun Test1(fn fun(Int, Int)(Int, Int)) {
        var i1, i2 = fn(1, 2)
    }
    Test1(fun i1, i2 { ret i1, i2 })

    fun Test2(fn fun()(Int)) {
        var i1 = fn()
    }
    Test2(fun {1})

    fun Test3(fn fun(Int)) {
        fn(1)
    }
    Test3( fun it Int {
        Print(it)
    })
    Test3( fun it {
        Print(it)
    })
    fun Test4(fn fun(Int)(Int)) { 
        fn(18) 
    }
    Test4(fun it {it+1})
}

fun Test_define() {
    var a = 1
    if a == 1 {
        var b = 2
        b = 3
        a = 3
    } else if a == 2 {
        var b = 2
        b = 3
        if b == 2 {
            a = 1
        }
    } else {
        var b = 2
        b = 3
        a = 3
    }
    if a case == 1 {
        var b = 2
        b = 3
        a = 3
        if a == 3 {
            b = 1
            a = 1
        } else {
            a = 2
        }
    } case is Int c {
        c = 2
        a = 1
    } else {
        var b = 2
        b = 3
        a = 3
    }
    ! {
        a = 2
    } or => e {
        e = Exception new ()
    }
}

fun Test_interface(i Protocol) {}

var Const_data = 256
var Const_data2 Str = "512"
var Const_data3 Int = Const_data
fun Const_function() (v Int) { 
    ret Const_data
}

fun 测试中文(甲 Int) (乙 Int) {
    var 乙 = 甲 + 1
    ret 乙
}

In_package_array := $(Arr List[Int]) {}
In_package_array := (->$me) {
    me.Arr = List_of(1,2,3,4,5)
}

Defer := $(data Str = "") {
    IDisposable
    Dispose := () {}
}

App := $(
    i Int = 1,
    arr ?Array[Int] = nil,
    _Name Str = "name",
    _b Int = 3,
    `get, set`
    a Int = 5,
    `get, set`
    f Str = ""
) {
    Program
    Protocol

    Test_package := () {
        var Item = Program new ()
        Item = new ()
        var Item2 = List[Int] new ()
        var Item3 = Dict[Str, Int] new ()
        var Item4 = Package_child new (1,2)
    }

    Test_func_template := [t1, t2](data1 t1, data2 t2 -> data App) {
        ret this
    }

    C := (x Int -> y Int) {
        ret x + this._b
    }

    D := (-> x Int) {
        ret 3
    }

    E := (->) {
    }
}

Result := $(Data Str = "") {}

Test_package_template := [t class]$(data t) {
    Generic := (a t) {}
}

Test_protocol_template := [t class]$ {
    Test : [h class](i h->)
    Test : (i t->)
}

Test_implement_template := $() {
    Test_protocol_template[Test_implement_template]
    
    Test := [h class](i h) {}
    Test := (i Test_implement_template) {}
}

Program := $(`get, set`name Str = "", running Bool = false) {}

Protocol := $ {
    C : (x Int -> y Int)
    D : (->y Int)
    E : (->)
}

`"SQL ORM", Table("test")`
Test_annotation := $(
    `Key, Column("id")`
    id Str,
    `Column("nick_name")`
    nick_name Str,
    `Column("profile")`
    profile Str
) {}

Test_enum := $Ok or Err{}

Package := $(x Int = 1, y Int = 2) { me ->
    ParentFunc := () {
        me.x = 21
        Print("package")
    }
}
Package := (y Int->$me) {
    me.x = Const_data
    me.y = y
}

Package_child := (x Int, y Int->$)(y) {
    this.x = x
}
Package_child := $() { me, super ->
    Package

    .ParentFunc := () {
        x = 64
        Print("package child")
    }
}