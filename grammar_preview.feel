-- Grammar Overview

-- Export Name Space
<- demo

-- Import Name Space
-> {
    System
    System.Linq
    System.Text
    System.Threading.Tasks
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    . = IO.File -- 可以隐藏元素使用内容
}

main = () {
    -- Define, 一般情况下编译器会自动判断类型
    string = "10"   -- str
    number = 1.2    -- num
    integer = 123   -- int
    boolean = true  -- bool
    smallFloat = (1.2).to_f32() -- basic type convert

    -- Const
    pi = 3.141592653

    -- Mark String
    format = "the value is ${integer}, ${number}, ${boolean}"

    -- Array
    array : array`int = array`int{1;2;3}

    -- List
    !list = list`int{ 1;2;3;4;5 }
    list = { 1;2;3;4;5 }
    print( list[0] ) -- 使用下标获取

    -- Set
    set = hashset`int{ 1;2;3;4;5 }

    -- Dictionary, 前面为key，后面为value
    !dict = dict`str`bool{["1"]=false; ["2"]=true}
    dict = { ["1"]=false; ["2"]=true}
    print( dict["1"] ) -- 使用key获取

    stack = stack`int{}
    queue = queue`int{}

    -- Anonymous Template
    new = ${
        title = "nnn"
        number = 8
    }{}

    -- Function
    fn = (in : int -> out : int) {} -- (int->int)

    -- Function with no params no return
    do_something_void = (->) {
        do_something_a()
        do_something_b()
    }

    -- Full Function with in params and out params
    do_something_with_params = (x : int, y : str -> a : int, b : str) {
        <- x, y
    }

    -- Function can omit return type
    funtion = (x : int, y : int) {
        <- x + y
    }

    do_something_void()
    -- 使用 _ 舍弃返回值
    _ = do_something_with_params(3, "test")

    -- Judge，当表达式的结果只有Bool时，相当于if，只当True时才执行
    1 + 1 >< 2 ? {
        do_something_a()
    }
    | ? {
        do_something_b()
    }

    1 + 1 >< 2 ? {
        print(2)
    }
    | 2 + 1 > 3 ? {
        print(3)
    }
    | ? {
        print("else")
    }

    a, b = 1, 2; a < b ? {
        do_something()
    }

    -- Judge type
    ib :: ImageButton ? {
        -- Convert type
        (ib !! View).show()
    }

    -- Switch
    x == 
    | 1 | 2 | 3 ? {
        do_something()
    }
    | 4 ? {
        do_something()
    }
    | ? {
        do_something()
    }
    -- Match
    x :: 
    | int => it ? {
        do_something()
    }
    | str => it ? {
        do_something()
    }
    | ? {
        do_something()
    }
    -- Complex Judge
    x
    | @@ 0..6 | == 7 | == 8 | == 9 ? {
        do_something_a()
    }
    | == 14 ? {
        do_something_b()
    }
    | < 18 ? {
        do_something_c()
    }
    | > 18 & < 32 ? {
        do_something_d()
    }
    | :: int ? {
        do_something_e()
    }
    | ? {
        do_something()
    }

    -- Loop, use identify to take out single item, default is it  
    array @ item {
        print(item)
    }
    -- take index and value, both worked at Dictionary
    array @ [index]value {
        print(index, value)
    }

    -- Iterator, Increment from ~ step .. to, Decrement from ~ step ... to, ~ step can omit
    0 .. 100 @ it {
        print(it)
    }
    10 ... 1 @ it {}

    -- Infinite
    true @ {
        a > b ? {
            ~@  -- jump out loop
        }
        @   -- continue
    }
    -- Conditional
    !a = 0
    a < 10 @ {
        a += 1
    }
    | @ {
        -- Loop else
    }

    !a = 0; a < 10 @ {
        a += 1
    }
    
    -- Check, listen the Exception Function
    fi = open_file("./test.feel")
    f = read_file("demo.feel"); F ! {
        do_some_thing()
    }
    {
        do_some_thing()
    } 
    & ex ! {
        ! <- ex -- Use ! <- to throw an Exception
    } 
    & ! {
        fi.dispose()
    }

    -- Template
    view = $ {
        !width : int
        !height : int
        !background : str
    }

    -- 可以通过 me 来访问包自身属性或方法，当作为指针类型使用时 me 是指针，否则是值类型。
    button = $ me {
        !width : int
        !height : int
        !background : str
        !title : str
        click = () {
            print( me.title )
            doSomeThingA()
            doSomeThingB()
        }
    }

    image = $ me {
        -- 私有属性，不能被外部访问
        !_width = 0
        !_height = 0
        !_source = ""
        init = (w : int, h : int, s : str->v : image) {
            me._width, me._height, me._source = w, h, s
            <- me
        }
    }

    -- Interface
    animation = $ {
        move : (s : int ->)
        stop : (->)
    }

    -- Combine Template
    image_button = $ me {
        . image
        . button
        !title : str
        -- Implement Interface
        move = (s : int) {
            t = 5000/s
            play( s + t )
        }
        stop = () {}

        init = (w : int, h : int->v : image_button) {
            me.image.init(w, h, "img")
            me.title = "img btn"
            <- me
        }
    }

    -- Create an Template object
    ib = image_button{}
    -- Calling property
    ib.title = "OK"
    -- Calling method
    ib.button.show()
    -- Calling protocol
    ib.move(6)

    -- Use Interface
    play_animation = (a : `animation) {
        a.move(1000)
        a.stop()
    }

    play_animation(ib)

    -- Create an object with simple assign
    ib2 = image_button{
        title = "Cancel"
        background = "red"
    }

    -- Create an object with params
    img = image{}.init(30, 20, "./icon.png")
    imgbtn = image_button{}.init(1, 1)

    task = (in : int -> out : int) {
        -- make a function to async
        ~> do_some_thing_A()
        -- make a function to await
        do_some_thing_B~>()
        -- make channel
        ch = chan`int(1)
        -- await
        ch <~ in
        -- await
        <- <~ ch
    }

    x = task(6)

    -- Annotation
    [table("user"), property(false, name = "d", hide = true)]
    user = $ {
        [column("id"), required, key]
        !id : str
        [column("nick_name"), required]
        !nick_name : str
        [column("time_update"), required]
        !time_update : int
    }

    -- Optional Type
    a : int? = nil
    -- Safe Call
    e = a?.to_str()
    -- OrElseValue
    f = a ?? 128

    -- Reference
    swap = (!x : int!, !y : int!) {
        x?, y? = y?, x?
    }
    !a, !b = 1, 2
    swap(a!, b!)
    
    -- Generic Template
    table`t = $ {
        !data : t
        set_data = (d : t) {
            data = d
        }
    }
    -- Generic function
    add`t = (x1 : t, x2 : t -> y : t) {
        <- x1 + x2
    }

    -- Lambda Function
    arr.select( (it){it > 2} )

    -- Func params
    func = (in : (x : int -> y : int)) {
        in(1)
    }
    func( (x : int -> y : int) {
        <- y
    })

    -- linq
    arr = expr @ id -> where expr -> order expr -> select expr

    color = $ {
        | red
        | green
        | blue
    }

    -- operator override
    complex = $ {
        !v : int
        !i : int

        -- add
        + = (x : complex->y : complex) {
            <- complex{ v = v + x.v; i = i + x.i }
        }

        -- index get
        [x : bool] = (->y : int) {
            x ? {
                <- v
            }
            <- i
        }
        -- index set
        [x : bool] = (y : int->) {
            x ? {
                v = y
                <-
            }
            i = y
        }
    }
}
