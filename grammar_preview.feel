-- Grammar Overview

-- Export Name Space
<- demo

-- Import Name Space
-> {
    System
    System.Linq
    System.Text
    System.Threading.Tasks
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    . = IO.File -- 可以隐藏元素使用内容
}

Main = () {
    -- Define, 一般情况下编译器会自动判断类型
    String = "10"   -- str
    Number = 1.2    -- num
    Integer = 123   -- int
    Boolean = true  -- bool
    SmallFloat = (1.2).to_f32() -- basic type convert

    -- Const
    PI = 3.141592653

    -- Mark String
    Format = "the value is ${Integer}, ${Number}, ${Boolean}"

    -- Array
    Array: array`int = array`int{1;2;3}

    -- List
    !List = list`int{ 1;2;3;4;5 }
    List = { 1;2;3;4;5 }
    print( List[0] ) -- 使用下标获取

    -- Set
    Set = hashset`int{ 1;2;3;4;5 }

    -- Dictionary, 前面为key，后面为value
    !Dictionary = dict`str`bool{["1"]=false; ["2"]=true}
    Dictionary = { ["1"]=false; ["2"]=true}
    print( Dictionary["1"] ) -- 使用key获取

    Stack = stack`int{}
    Queue = queue`int{}

    -- Anonymous Template
    New = ${
        title = "nnn"
        number = 8
    }{}

    -- Function
    Fn = (in: int -> out: int) {} -- (int->int)

    -- Function with no params no return
    do_something_void = (->) {
        do_something_a()
        do_something_b()
    }

    -- Full Function with in params and out params
    do_something_with_params = (x: int, y: str -> a: int, b: str) {
        <- x, y
    }

    -- Function can omit return type
    funtion = (x: int, y: int) {
        <- x + y
    }

    B2C()
    -- 使用 _ 舍弃返回值
    _ = A2B(3, "test")

    -- Judge，当表达式的结果只有Bool时，相当于if，只当True时才执行
    1 + 1 >< 2 ? {
        do_something_a()
    } _ ? {
        do_something_b()
    }
    ? {
        | 1 + 1 >< 2 ?
            print(2)
        | 2 + 1 > 3 ?
            print(3)
        | _ ?
            print("else")
    }

    a, b = 1, 2; a < b ? {
        do_something()
    }

    -- Judge type
    IB :: ImageButton ? {
        -- Convert type
        (IB !! View).show()
    }

    -- switch
    x == 1 | 2 | 3 ? {
        do_something()
    } _ ? {
        do_something()
    }
    x == ? {
        | 1 | 2 | 3 ?
            do_something()
        | 4 ?
            do_something()
        | _ ?
            do_something()
    }
    -- match
    x :: int | str ? {
        do_something()
    } _ ? {
        do_something()
    }
    x :: ? {
        | int => it ?
            do_something()
        | str => it ? 
            do_something()
        | _ ?
            do_something()
    }
    -- Complex Judge
    x ~ @@ 0..6 | == 7 | == 8 | == 9 ? {
        do_something_a()
    } _ ? {
        do_something()
    }
    x ~ ? {
        | @@ 0..6 | == 7 | == 8 | == 9 ? 
            do_something_a()
        | == 14 ?
            do_something_b()
        | < 18 ? 
            do_something_c()
        | > 18 & < 32 ? 
            do_something_d()
        | :: int ? 
            do_something_e()
        | _ ?
            do_something()
    }

    -- Loop, use identify to take out single item, default is it  
    array @ item {
        print(item)
    }
    -- take index and value, both worked at Dictionary
    array @ [index]value {
        print(index, value)
    }

    -- Iterator, Increment from ..(step) to, Decrement from ...(step) to, (step) can omit
    0 .. 100 @ it {
        print(it)
    }
    10 ... 1 @ it {}

    -- Infinite
    true @ {
        a > b ? {
            ~@  -- jump out loop
        } _ ? {
            @   -- continue
        }
    }
    -- Conditional
    !a = 0
    a < 10 @ {
        a += 1
    } _ @ {
        -- Loop else
    }

    !a = 0; a < 10 @ {
        a += 1
    }
    
    -- Check, listen the Exception Function
    Fi = File("./test.feel")
    F = Read_File("demo.feel"); F ! {
        do_some_thing()
    }
    {
        do_some_thing()
    } ex ! {
        ! <- ex -- Use ! <- to throw an Exception
    } _ ! {
        Fi.Dispose()
    }

    -- Template
    View = $ {
        !width: int
        !height: int
        !background: str
    }

    -- 可以通过 me 来访问包自身属性或方法，当作为指针类型使用时 me 是指针，否则是值类型。
    Button = $ me {
        !width: int
        !height: int
        !background: str
        !title: str
        click = () {
            print( me.title )
            doSomeThingA()
            doSomeThingB()
        }
    }

    Image = $ me {
        -- 私有属性，不能被外部访问
        !_width = 0
        !_height = 0
        !_source = "" 

        init = (w: int, h: int, s: str->v: Image) {
            me._width, me._height, me._source = w, h, s
            <- me
        }
    }

    -- Interface
    Animation = $ {
        move: (s: int ->)
        stop: (->)
    }

    -- Combine Template
    ImageButton = $ me {
        . Image
        . Button
        !title: str
        -- Implement interface
        move = (s: int) {
            t = 5000/s
            play( s + t )
        }
        stop = () {}

        init = (w: int, h: int->v: ImageButton) {
            me.Image.init(w, h, "img")
            me.title = "img btn"
            <- me
        }
    }

    -- Create an Template object
    IB = ImageButton{}
    -- Calling property
    IB.title = "OK"
    -- Calling method
    IB.button.show()
    -- Calling protocol
    IB.move(6)

    -- Create an object with simple assign
    IB2 = ImageButton{
        title = "Cancel"
        background = "red"
    }

    -- Create an object with params
    Img = Image{}.init(30, 20, "./icon.png")
    ImgBtn = ImageButton{}.init(1, 1)

    -- get type
    print( typeof(ImageButton) )

    task = (in: int -> out: int) {
        -- make a function to async
        ~> do_some_thing_A()
        -- make a function to await
        do_some_thing_B~>()
        -- make channel
        ch = chan`int(1)
        -- await
        ch <~ in
        -- await
        <- <~ ch
    }

    x = task(6)

    -- Annotation
    [Table("user"), D(false, Name="d", Hide=true)]
    User = $ {
        [Column("id"), Required, Key]
        !id: str
        [Column("nick_name"), Required]
        !nick_name: str
        [Column("time_update"), Required]
        !time_update: int
    }

    -- Optional Type
    A: int? = nil
    -- Safe Call
    E = A?.to_str()
    -- OrElseValue
    F = A ?? 128

    -- Reference
    swap = (!x: int!, !y: int!) {
        x?, y? = y?, x?
    }
    !a, !b = 1, 2
    swap(a!, b!)
    
    -- Generic Template
    table = `T $ {
        !data: T
        set_data = (d: T) {
            data = d
        }
    }
    -- Generic function
    Add = `T (x1: T, x2: T -> y: T) {
        <- x1 + x2
    }

    -- Lambda Function
    arr.select( (it){it > 2} )

    -- Func params
    Func = (in: (x: int -> y: int)) {
        in(1)
    }
    Func( (x: int -> y: int) {
        <- (y)
    })

    -- linq
    arr = expr @ id -> where expr -> order expr -> select expr

    Color = $ {
        | Red
        | Green
        | Blue
    }

    -- operator override
    complex = $ {
        !v: int
        !i: int

        -- add
        + = (x: complex->y: complex) {
            <- complex{ v = v + x.v; i = i + x.i }
        }

        -- index get
        [x: bool->] = (->y: int) {
            x ? {
                <- v
            } _ {
                <- i
            }
        }
        -- index set
        [x: bool->] = (y: int->) {
            x ? {
                v = y
            } _ {
                i = y
            }
        }
    }
}
