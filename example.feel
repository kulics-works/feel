<- example

-> {
    System
    System.IO
    System.Linq
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    System.Threading.Tasks

    . = example.example_static
}

++
    main function
++
Main = () {
    print("main function")
    -- "run test"
    Test_type()
    Test_operator()
    Test_string()
    Test_optional()
    Test_list()
    Test_set()
    Test_dict()
    Test_stack()
    Test_queue()
    Test_switch()
    Test_if()
    Test_foreach()
    Test_while()
    X = Test_func("testcall")
    Test_func_params(1, 2,
    (a : int, b : int, c : int, d : i8 -> z : str, a : int, b : int, c : int) {
        <- "", a, b, c
    })
    Test_check()
    Test_type_convert()
    Test_empty()
    Test_lambda()
    Test_linq()
    Test_async()

    Y = Test_tuple(1).to_str()

    P = example.App{}

    P.C(1)
    Test_interface(P)

    P.Test_func_template`int`str(1, "2").Test_package()
    
    true @ {
        ~@
    }
    
    1 == 1 ? {
        print("test exception expression")
    }

    read()
}

[get, set]
static_x = 0

[get(i){i}, set(i,v){i=v}]
static_y = "hello"

[get(){static_x}, set(v){static_x=v}]
static_z : int

static_g : i64

Test_tuple = (i : int -> v : str) {
    <- "tuple"
}

Test_type = () {
    I1 : i8 = 1              -- sbyte
    I2 : i16 = 1             -- short
    I3 : i32 = 1             -- int
    I4 : i64 = 1             -- long
    U1 : u8 = 1              -- byte
    U2 : u16 = 1             -- ushort
    U3 : u32 = 1             -- uint
    U4 : u64 = 1             -- ulong
    F1 : f32 = 1             -- float
    F2 : f64 = 1             -- double
    Char1 : chr = 'a'        -- char
    String1 : str = "123"    -- string
    Bool1 : bool = false     -- bool
    Int1 : int = 1           -- int
    Num1 : num = 1.0         -- double
    Byte1 : byte = 1         -- byte
    Any1 : any = 1           -- object
}

Test_operator = () {
    i : str = "128.687"
    i += ".890"
    A = 003.141592653e3
    b : int
    b = 2020_01_16
    b = 0b1010_1101
    b = 0X56_fa_C4
    b += Const_data
    b = + - b
    b = b + 1
    b = b * 2
    b = b / 2
    b = b % 2
    b = (b ^ 2) !! int
    print(" mark string int \b ${b}123{} \${b} ${i;i}")
    print(""" "raw" mark string \b
     int ${b}123{} $ {}
      ${i}
    """)
    print(""" 
       " raw "
        string
      """, """""")
    c = false
    c = 1 <> 2
    c = 3 == 3
    c = 3 >= 1
    c = 1 <= 3
    c = ~~c
    c = true || false
    c = true && false
    d = (2018.0309).to_int() 
    d = ~~~ d &&& 1 ||| 2 ^^^ 3 <<< 1 >>> 2
    print(b.to_str(), d)
}

Test_string = () {
    "love programming" @ E {
        E == 'e' ? {
            print("love programming")
        }
    }
}

Test_optional = () {
    a : int?
    a = 1
    a?.to_str()
    B : str? = ""
    B?.to_str()
    C : any? = nil
    D : App? = nil
    E : (list`int?)? = list`int?{0}
    E?[0]?.to_str()?.to_str()
    F = D ?? App{}
}

Test_reference = () {
    x : int = 1
    y : int? = 2
    Swap = (!a : int, !b : int? ->) {
        b, a = a, b ?? 2
    }
    Swap(x!, y!)
}

Test_empty = () {
    X = empty`Program()
    Y = empty`Protocol()
    Z = empty`(int->int)()
}

Test_list = () {
    Single = {1}
    numbers = {1;2;5;6;8;4}
    numbers = numbers + 0
    numbers += 3 + 7
    numbers -= 6
    Three = 3
    numbers[Three] = 5
    take = numbers[0]
    take = In_package_array{}.Arr[2]
    Anys = {"123"; 432; App{}}
    Numbers_in_numbers = {{1;1;1}; {1;1;1}}
    Numbers_in_numbers[0][0] = 3
    Empty = list`(list`int){}
    Array : array`int = array_of(1, 2, 3)
    numbers @ [i]v {
        print(i, " :", v)
    }
    Slice = numbers[0..]
    Slice2 = numbers[..3]
}

Test_set = () {
    Empty = hashset`str{}
    Numbers = hashset`int{1;2;5;6;8;4}
    Numbers @ item {
        print(item)
    }
}

Test_dict = () {
    Empty = dict`str`(dict`int`int){}
    temp = {["k1"]=1;["k2"]=2}
    temp += {["k3"]=3}
    temp @ [k]v {
        print(k)
        print(v)
    }
    temp -= "k1"
    print(temp["k2"])
}

Test_stack = () {
    Temp = stack`int{}
    Temp.push(1)
    Temp.pop()
}

Test_queue = () {
    Temp = queue`int{}
    Temp.enqueue(1)
    Temp.dequeue()
}

Test_combined_type = () {
    -- swift [int :[[str :[str :[str]]]]]
    -- go map[int][]map[str]map[str][]str
    -- c# map<int,list<map<str,map<str,list<str>>>>>
    Feel : dict`int`(list`(dict`str`(dict`str`(list`str))))
}

Test_if = () {
    X = 5
    X == 2 ? { 
        print(2)
    }
    | X == 3 ? {
        print(3)
    }
    | ? { 
        print("else")
    }
    X == 5 ? {
        print("yes")
    }
    Y = X == 5 ? {
            X * X
        }
        | ? {
            0
        } == 0 ? {
            1
        }
        | ? {
            2
        }
}

Test_type_convert = () {
    A : any = dict`str`int{}
    B = A !! dict`str`int
    X = App{}
    Y = X !! Program
    Z1 = (12.34).to_f32()
    Z2 = Z1.to_i64()
    print( Z2.to`any().to`i64() )
    print( Y :: Program )
    print( (X !! Program).running )
    print( typeof(Program) )
}

Test_switch = () {
    X : any = 3
    X ==
    | 1 | 2 | 3 ? {
        print("1,2,3") 
    }
    | nil ? {
        print("null") 
    }
    | ? {
        print("default")
    }
    X :: 
    | str ? {
        print("string")
    }
    | int => i ? {
        print("int")
    }
    | ? {
        print("default")
    }
}

Test_foreach = () {
    print(" 0 to 10")
    0 .. 10 @ E {
        print(E, ", ", "")
    }
    print(" ")
    print(" 0 to 8 step 2")
    0 ..< 8 ^^ 2 @ E {
        print(E, ", ", "")
    }
    print(" ")
    print(" 8 to 0 step 2")
    8 ..> 0 ^^ 2 @ E {
        print(E, ", ", "")
    }
    print(" ")
    print(" 8 to 2 step 2")
    10 ... 0 @ E {
        print(E, ", ", "")
        E == 6 ? {
            @
        }
    }
    print(" ")
    Arr = list`int{}
    Arr @ I {
        print(I)
    }
    7 .. 7 @ I {
        print(I)
        ~@
    }
}

Test_while = () {
    a = 0
    B = 8
    a < B @ {
        a += 1
    }
    | @ {
        print("loop else")
    }
}

Test_check = () {
    z1 : Defer? = nil
    -> Z2 = Defer{} {
        {
            z1 = Defer{}
            -> Z3 = Defer{} {
                X = 1 * 1
                Y = 1 + 1
            }
        }
        & ex : IOException ! {
            ! <- ex
        }
        & e ! {
            ! <- e
        }
        & ! {
            z1 <> nil ? {
                z1.Dispose()
            }
        }
    }
}

Test_func = (s : str -> out1 : str, out2 : int) {
    s = s + "test"
    I1 = 1+1*3*9/8
    I2 = I1 + 5 + (I1 + 8)
    Infunc = (->) {
        <-
    }
    Infunc()

    <- s, I2
}

Test_func_params = (a : int, b : int, fn : (int, int, int, i8 ->
    str, int, int, int), arr : ,,,int -> a : int, b : str, c : str) {
    <- 0, "", ""
}

Test_lambda = () {
    Test1 = (fn : (int, int -> int, int)) {
        i1, i2 = fn(1, 2)
    }
    Test1( (i1, i2){i1, i2} )

    Test2 = (fn : (->int)) {
        i1 = fn()
    }
    Test2(() {1})

    Test3 = (fn : (int ->> )) {
        fn(1)
    }
    Test3( (it : int ->> ) {
        delay~>(1000)
        print(it)
    })
    Test3( (it>) {
        delay~>(1000)
        print(it)
    })
    Test4 = (fn : (int ->> int)) { 
        fn(18) 
    }
    Test4((it>) {it+1})
}

Test_async = (->> x : int, y : int, z : str) {
    sleep(1000)
    1 .. 10 @ i {
        go((>) {
            delay~>(1000)
            print("task", i)
        })
    }
    Async_void = () {
        delay~>(1000)
    }
    Func_await = (->> x : int, y : int, z : str) {
        delay(1000)
        <<- 1, 2, "123"
    }
    <- Func_await~>()
}

Test_linq = () {
    Numbers = {0; 1; 2; 3; 4; 5; 6}
    Linq = @ i = Numbers -> where (i % 2) == 0 ->
    orderby i -> descending -> select i
    Lambda = Numbers.Where((i) { i%2==0 }).OrderBy((i) { i }).ToList()
}

Test_define = () {
    a = 1
    a == 1 ? {
        b = 2
        b = 3
        a = 3
    }
    | a == 2 ? {
        b = 2
        b = 3
        b == 2 ? {
            a = 1
        }
    }
    | ? {
        b = 2
        b = 3
        a = 3
    }
    a == 
    | 1 ? {
        b = 2
        b = 3
        a = 3
        a == 3 ? {
            b = 1
            a = 1
        }
        | ? {
            a = 2
        }
    }
    a :: 
    | int => c ? {
        c = 2
        a = 1
    }
    | ? {
        b = 2
        b = 3
        a = 3
    }
    {
        a = 2
    }
    & e ! {
        e = Exception{}
    }
}

Test_interface = (in : Protocol) {}

Const_data = 256
Const_data2 : str = "512"
Const_data3 : int = Const_data
Const_function = (->v : int) { 
    <- Const_data
}

测试中文 = (甲 : int->乙 : int) {
    乙 = 甲 + 1
    <- 乙
}

In_package_array = $ {
    Arr : list`int = {1;2;3;4;5;6;7}
}

Defer = $ {
    IDisposable
    data = ""

    Dispose = () {}
}

App = $ me {
    Program
    Protocol
    i = 555
    arr = {1;1;1;1}
    _Name = " program "
    _b = 5
    [get(i){i}, set(i,v){i=v}]
    a = 1

    Test_package = () {
        Item = Program{name = "new program"; running = true}
        Item2 = ${
            name = "new program"
            running = true
        }{}
        Item3 = list`int{1;2;3;4;5}
        Item4 = dict`str`int{["1"]=1;["2"]=2;["3"]=3}
        Item5 = Package_child(1,2)
    }

    Test_func_template`t1`t2 = (data1 : t1, data2 : t2 -> data : App) {
        <- me
    }

    [get(){me._b}, set(v){me._b = v}]
    b : int
    [get, set]
    f : str

    C = (x : int -> y : int) {
        <- x + me._b
    }

    D = (->> x : int) {
        delay~>(1000)
        <- 3
    }

    E = (->>) {
        delay~>(1000)
    }
}

Result = $ {
    Data : str
}
Result = (data : str->$me) {
    me.Data = Data
}

Test_package_template`(t:class) = $ {
    data : t
    Generic = (a : t) {}
}

Test_protocol_template`(t:class) = {
    Test`(h:class) : (in : h->)
    Test : (in : t->)
}

Test_implement_template = $ me {
    Test_protocol_template`Test_implement_template
    Test = (in : Test_implement_template) {}
    Test`(h:class) = (in : h) {}
}

Program = $ {
    running : bool
}

Program = $ {
    [get, set]
    name : str
}

Protocol = {
    C : (x : int -> y : int)
    D : (->>y : int)
    E : (->>)
}

["SQL ORM", Table("test")]
Test_annotation = $ {
    [Key, Column("id")]
    id : str
    [Column("nick_name")]
    nick_name : str
    [Column("profile")]
    profile : str
}

Test_enum = $ {
    | ok
    | err = -1
}

Package = $ me {
    x : int
    y : int

    ParentFunc = () {
        me.x = 21
        print("package")
    }
}
Package = (y : int->$me) {
    me.x = Const_data
    me.y = y
}

Package_child = (x : int, y : int->$me)(y) {
    me.x = x
}
Package_child = $ me, super {
    Package

    .ParentFunc = () {
        x = 64
        print("package child")
    }
}
Package_child = $ {
    A = 7

    B = () {
        print("static")
    }
}{}