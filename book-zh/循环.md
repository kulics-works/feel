# 循环
有的时候，我们可能需要多次执行同一块代码。

一般情况下，语句是按顺序执行的，函数中的第一个语句先执行，接着是第二个语句，以此类推。
## 集合循环
如果我们刚好有一个集合，可以是数组、字典、或是一段文本，那么我们就可以使用 `value.@ id {}` 语句来遍历这个集合，取出的每一个元素为 `id`。

例如：
```
arr := [1, 2, 3, 4, 5]
arr.@ item
{
    Console.WriteLine.(item)    // 打印每一个数字
}
```
`@` 后面跟着的标识符就是当前被取出来的值，这个标识符仅在当前循环内有效。所以我们不需要在外部定义一个标识符。
如果我们不想定义额外的标志符，可以省略，默认为`it`。

例如：
```
arr.@
{
    Console.WriteLine.(it)      // 打印每一个数字
}
```

相对于其它语言来说，这可以认为是 `foreach` 结构。
## 迭代器循环
有些时候，我们未必刚好就有一个集合，但是我们又需要从 `0` 到 `100` 去取数。我们有一个迭代器语法可以完成这样的任务。

迭代器可以从起点向终点循环取数，我们使用集合的表达方式，在两个数之间使用 `~` 符号隔开即可。

例如：
```
[0 ~ 100].@
{
    Console.WriteLine.(it)      // 打印每一个数字
}
```
需要注意的是，`0 ~ 100` 的意义是从 `0` 逐次读取到 `100` ，也就是一共执行了 `101` 次。迭代器会执行到最后一个数字被执行完毕，而不是提前一次结束。

因此如果我们需要的是执行一百次，可以使用 `0 ~ 99` 或 `1 ~ 100` ，切记这个区别。

迭代器默认每次间隔累加`1`，如果我们需要每隔一个数取一次，可以增加一个每步条件，只需要在起点和终点完成后再插入`;`和一个数字即可。

例如：
```
[0 ~ 100; 2].@ 
{
    ...
}
```
这样每次间隔就不是 `1` 而是 `2` ，同理我们可以设置其它数字。

既然如此，我们也可以让它倒序遍历，只要使用负数每步条件即可。

例如：
```
[100 ~ 0; -1].@ 
{
    ...     // 从100到0
}
```

相对于其它语言来说，这可以认为是 `for` 结构。
## 无限循环
在另一些时候，我们可能会需要一个无限循环。非常容易的是，我们只需要使用`@ {}`声明即可。

例如：
```
@
{
    ...     // 永远不会跳出
}
```
相对于其它语言来说，这可以认为是 `while` 结构。
## 跳出
那么要如何跳出无限循环呢？我们可以使用辅助符号 `~@`来跳出。

例如：
```
@
{
    ~@     // 什么都没执行就跳出了
}
```
除了无限循环，跳出也可以在其它循环中使用。

需要注意的是，如果跳出在多层嵌套的循环中，只会跳出最靠近自己的那一层循环。
## 条件循环
如果我们需要一个只判断某个条件的循环怎么做呢？
加一个条件就可以了。

例如：
```
i := 0
@ i < 6 
{
    i += 1
}
```

### [下一章](函数类型.md)

## 本章示例
```
Demo
{
    .. System

    Main ()
    {
        arr := [1,2,3,4,5]
        arr.@ 
        {
            Console.WriteLine.(it)
        }

        [1 ~ 50].@ i
        {
            Console.WriteLine.(i)
        }

        [100 ~ 0 ; -1].@ i
        {
            Console.WriteLine.(i)
        }

        x := 0
        @ x <= 10
        {
            x += 1
        }
    }
}
```

